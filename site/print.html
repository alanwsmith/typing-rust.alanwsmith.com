<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js navy">
    <head>

        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Typing Rust</title>
        <meta name="robots" content="noindex" />

        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/overrides.css">


    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "navy";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('navy')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction/index.html"><strong aria-hidden="true">1.</strong> Hello, World</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="introduction/your-turn.html"><strong aria-hidden="true">1.1.</strong> Your Turn</a></li></ol></li><li class="chapter-item expanded "><a href="introduction/status-line.html"><strong aria-hidden="true">2.</strong> The Status Line</a></li><li class="chapter-item expanded "><a href="cards/index.html"><strong aria-hidden="true">3.</strong> Quick Notes</a></li><li class="chapter-item expanded "><a href="variables/index.html"><strong aria-hidden="true">4.</strong> Variables</a></li><li class="chapter-item expanded "><a href="printing/index.html"><strong aria-hidden="true">5.</strong> Printing Variables</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="printing/step-by-step.html"><strong aria-hidden="true">5.1.</strong> Step By Step</a></li><li class="chapter-item expanded "><a href="printing/your-turn.html"><strong aria-hidden="true">5.2.</strong> Your Turn</a></li></ol></li><li class="chapter-item expanded "><a href="mutable-variables/index.html"><strong aria-hidden="true">6.</strong> Mutable Variables</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="mutable-variables/example.html"><strong aria-hidden="true">6.1.</strong> Step By Step</a></li><li class="chapter-item expanded "><a href="mutable-variables/your-turn.html"><strong aria-hidden="true">6.2.</strong> Your Turn</a></li></ol></li><li class="chapter-item expanded "><a href="functions/index.html"><strong aria-hidden="true">7.</strong> Functions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="functions/no-arguments-no-return-value.html"><strong aria-hidden="true">7.1.</strong> No Args Or Return Value</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="functions/no-arguments-no-return-value-step-by-step.html"><strong aria-hidden="true">7.1.1.</strong> Step By Step</a></li><li class="chapter-item expanded "><a href="functions/no-arguments-no-return-value-your-turn.html"><strong aria-hidden="true">7.1.2.</strong> Your Turn</a></li></ol></li><li class="chapter-item expanded "><a href="functions/has-arguments-no-return-value.html"><strong aria-hidden="true">7.2.</strong> Has Args But No Return Value</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="functions/has-arguments-no-return-value-step-by-step.html"><strong aria-hidden="true">7.2.1.</strong> Step By Step</a></li><li class="chapter-item expanded "><a href="functions/has-arguments-no-return-value-your-turn.html"><strong aria-hidden="true">7.2.2.</strong> Your Turn</a></li></ol></li><li class="chapter-item expanded "><a href="functions/no-arguments-but-has-return-values.html"><strong aria-hidden="true">7.3.</strong> No Args But Has Return Value</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="functions/no-arguments-but-has-return-values-step-by-step.html"><strong aria-hidden="true">7.3.1.</strong> Step By Step</a></li><li class="chapter-item expanded "><a href="functions/no-arguments-but-has-return-values-your-turn.html"><strong aria-hidden="true">7.3.2.</strong> Your Turn</a></li></ol></li><li class="chapter-item expanded "><a href="functions/has-arguments-has-return-value.html"><strong aria-hidden="true">7.4.</strong> With Args And Return Value</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="functions/has-arguments-has-return-value-your-turn.html"><strong aria-hidden="true">7.4.1.</strong> Your Turn</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="ownership/index.html"><strong aria-hidden="true">8.</strong> Ownership</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ownership/step-1.html"><strong aria-hidden="true">8.1.</strong> Step 1</a></li><li class="chapter-item expanded "><a href="ownership/step-2.html"><strong aria-hidden="true">8.2.</strong> Step 2</a></li><li class="chapter-item expanded "><a href="ownership/step-3.html"><strong aria-hidden="true">8.3.</strong> Step 3</a></li><li class="chapter-item expanded "><a href="ownership/what-does-not-happen.html"><strong aria-hidden="true">8.4.</strong> What Doesn't Happen</a></li><li class="chapter-item expanded "><a href="ownership/step-4.html"><strong aria-hidden="true">8.5.</strong> Step 4 - What Does Happen</a></li><li class="chapter-item expanded "><a href="ownership/step-5.html"><strong aria-hidden="true">8.6.</strong> Step 5</a></li><li class="chapter-item expanded "><a href="ownership/hitting-a-moved-error.html"><strong aria-hidden="true">8.7.</strong> Hitting A Moved Error</a></li><li class="chapter-item expanded "><a href="ownership/moving-string-error-details.html"><strong aria-hidden="true">8.8.</strong> Moving Error Details</a></li></ol></li><li class="chapter-item expanded "><a href="references/index.html"><strong aria-hidden="true">9.</strong> References</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="references/example.html"><strong aria-hidden="true">9.1.</strong> Example</a></li><li class="chapter-item expanded "><a href="references/step-1.html"><strong aria-hidden="true">9.2.</strong> Step 1</a></li><li class="chapter-item expanded "><a href="references/step-2.html"><strong aria-hidden="true">9.3.</strong> Step 2</a></li><li class="chapter-item expanded "><a href="references/working-example.html"><strong aria-hidden="true">9.4.</strong> Working Example</a></li><li class="chapter-item expanded "><a href="references/multiple-references.html"><strong aria-hidden="true">9.5.</strong> Multiple References</a></li></ol></li><li class="chapter-item expanded "><a href="references/function-argument-references.html"><strong aria-hidden="true">10.</strong> Function Argument References</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="references/function-argument-references-with-variables.html"><strong aria-hidden="true">10.1.</strong> With Variables</a></li><li class="chapter-item expanded "><a href="references/function-argument-references-error.html"><strong aria-hidden="true">10.2.</strong> Error Example</a></li></ol></li><li class="chapter-item expanded "><a href="references/mutable-function-argument-references.html"><strong aria-hidden="true">11.</strong> Mutable Function Argument References</a></li><li class="chapter-item expanded affix "><li class="part-title">Prototypes</li><li class="chapter-item expanded "><a href="prototypes/1.html"><strong aria-hidden="true">12.</strong> Prototype 1</a></li><li class="chapter-item expanded affix "><li class="part-title">Scratchpad</li><li class="chapter-item expanded "><a href="scratchpad/index.html"><strong aria-hidden="true">13.</strong> Scratchpad</a></li><li class="chapter-item expanded affix "><li class="part-title">Pending</li><li class="chapter-item expanded "><div><strong aria-hidden="true">14.</strong> Ownership Stuff</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="ownership/function-moves.html"><strong aria-hidden="true">14.1.</strong> Function Moves</a></li><li class="chapter-item expanded "><a href="ownership/function-move-errors.html"><strong aria-hidden="true">14.2.</strong> Function Move Errors</a></li></ol></li><li class="chapter-item expanded "><a href="if-expressions/index.html"><strong aria-hidden="true">15.</strong> If Expressions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="if-expressions/if-else.html"><strong aria-hidden="true">15.1.</strong> If/Else</a></li></ol></li><li class="chapter-item expanded "><a href="operators/index.html"><strong aria-hidden="true">16.</strong> Comparison Operators</a></li><li class="chapter-item expanded "><a href="variables-with-if-expressions/index.html"><strong aria-hidden="true">17.</strong> Variables With If Expressions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="variables-with-if-expressions/println-variables.html"><strong aria-hidden="true">17.1.</strong> println! Variables</a></li></ol></li><li class="chapter-item expanded "><a href="data-types/index.html"><strong aria-hidden="true">18.</strong> Data Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="data-types/i32.html"><strong aria-hidden="true">18.1.</strong> i32</a></li></ol></li><li class="chapter-item expanded "><a href="functions/arguments.html"><strong aria-hidden="true">19.</strong> Function Arguments</a></li><li class="chapter-item expanded "><a href="functions/conditional-functions.html"><strong aria-hidden="true">20.</strong> Program: NAME TKTKTKT</a></li><li class="chapter-item expanded "><a href="immutable-variables/index.html"><strong aria-hidden="true">21.</strong> Immutable Variables</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="mutable-variables/assigning-twice-error.html"><strong aria-hidden="true">21.1.</strong> Assigning Twice Error</a></li></ol></li><li class="chapter-item expanded "><a href="mutable-variables/index.html"><strong aria-hidden="true">22.</strong> Mutable Variables</a></li><li class="chapter-item expanded "><a href="programs/conditional-functions-v2.html"><strong aria-hidden="true">23.</strong> Program: NAME TKTKTKT V2</a></li><li class="chapter-item expanded "><a href="for-loops/index.html"><strong aria-hidden="true">24.</strong> for Loops With Ranges</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="for-loops/with-variables.html"><strong aria-hidden="true">24.1.</strong> With Variables</a></li></ol></li><li class="chapter-item expanded "><a href="arithmetic-operators/index.html"><strong aria-hidden="true">25.</strong> Arithmetic Operators</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="arithmetic-operators/division.html"><strong aria-hidden="true">25.1.</strong> Division Operator</a></li><li class="chapter-item expanded "><a href="arithmetic-operators/remainder.html"><strong aria-hidden="true">25.2.</strong> Remainder Operator</a></li><li class="chapter-item expanded "><a href="arithmetic-operators/with-comparison-operators.html"><strong aria-hidden="true">25.3.</strong> With Comparison Operators</a></li><li class="chapter-item expanded "><a href="arithmetic-operators/comparison-operators-with-variables.html"><strong aria-hidden="true">25.4.</strong> Comparison Operators With Variables</a></li><li class="chapter-item expanded "><a href="programs/for-mod-example.html"><strong aria-hidden="true">25.5.</strong> Using The Remainder</a></li><li class="chapter-item expanded "><a href="arithmetic-operators/using-the-remainder-v2.html"><strong aria-hidden="true">25.6.</strong> Using The Remainder V2</a></li></ol></li><li class="chapter-item expanded "><a href="booleans/index.html"><strong aria-hidden="true">26.</strong> Booleans</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="booleans/in-conditionals.html"><strong aria-hidden="true">26.1.</strong> In Conditionals</a></li></ol></li><li class="chapter-item expanded "><a href="function-return-values/index.html"><strong aria-hidden="true">27.</strong> Function Return Values</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="function-return-values/different-types.html"><strong aria-hidden="true">27.1.</strong> Different Types</a></li><li class="chapter-item expanded "><a href="function-return-values/returning-from-if.html"><strong aria-hidden="true">27.2.</strong> Returning From if</a></li><li class="chapter-item expanded "><a href="functions/as-conditions.html"><strong aria-hidden="true">27.3.</strong> Functions As Conditions</a></li></ol></li><li class="chapter-item expanded "><a href="programs/3.html"><strong aria-hidden="true">28.</strong> Program 3 NAME TKTKTKT</a></li><li class="chapter-item expanded "><a href="scopes/index.html"><strong aria-hidden="true">29.</strong> Scopes</a></li><li class="chapter-item expanded "><a href="strings/index.html"><strong aria-hidden="true">30.</strong> Strings</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="strings/mutable-strings.html"><strong aria-hidden="true">30.1.</strong> Mutable Strings</a></li></ol></li><li class="chapter-item expanded "><a href="concepts-ahead/index.html"><strong aria-hidden="true">31.</strong> Difficulty Increasing</a></li><li class="chapter-item expanded "><a href="illustrations-incoming/index.html"><strong aria-hidden="true">32.</strong> Illustrations Incoming</a></li><li class="chapter-item expanded "><a href="references/_index_old.html"><strong aria-hidden="true">33.</strong> References Old</a></li><li class="chapter-item expanded "><a href="mutable-references/_index_old.html"><strong aria-hidden="true">34.</strong> Mutable References</a></li><li class="chapter-item expanded affix "><li class="part-title">Holding Drafts</li><li class="chapter-item expanded "><div><strong aria-hidden="true">35.</strong> References Holding</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="references/a-single-value.html"><strong aria-hidden="true">35.1.</strong> A Single Value</a></li><li class="chapter-item expanded "><a href="references/using-in-a-function.html"><strong aria-hidden="true">35.2.</strong> Using In A Function</a></li><li class="chapter-item expanded "><a href="references/changing-in-a-function.html"><strong aria-hidden="true">35.3.</strong> Changing In A Function</a></li><li class="chapter-item expanded "><a href="references/a-function-error.html"><strong aria-hidden="true">35.4.</strong> A Function Error</a></li></ol></li><li class="chapter-item expanded "><a href="strings/moving-strings.html"><strong aria-hidden="true">36.</strong> Ownership And Moving</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="strings/moving-strings-error.html"><strong aria-hidden="true">36.1.</strong> Moving Error</a></li></ol></li><li class="chapter-item expanded "><a href="cloning/index.html"><strong aria-hidden="true">37.</strong> Cloning</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="cloning/separate-values.html"><strong aria-hidden="true">37.1.</strong> Separate Values</a></li></ol></li><li class="chapter-item expanded "><a href="if/binding-values.html"><strong aria-hidden="true">38.</strong> Binding Values From if</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="if/binding-values-must-be-the-same-type.html"><strong aria-hidden="true">38.1.</strong> Must Be The Same Type</a></li><li class="chapter-item expanded "><a href="if/mismatched-type-error.html"><strong aria-hidden="true">38.2.</strong> Mismatched Type Error</a></li></ol></li><li class="chapter-item expanded "><a href="sandbox/index.html"><strong aria-hidden="true">39.</strong> Sandbox</a></li><li class="chapter-item expanded affix "><li class="part-title">Holding</li><li class="chapter-item expanded "><a href="while-loops/index.html"><strong aria-hidden="true">40.</strong> While Loops</a></li><li class="chapter-item expanded "><a href="variables/variables-in-println.html"><strong aria-hidden="true">41.</strong> Variables In println!</a></li><li class="chapter-item expanded affix "><li class="part-title">Holding</li><li class="chapter-item expanded "><a href="data-types/string.html"><strong aria-hidden="true">42.</strong> String</a></li><li class="chapter-item expanded "><a href="data-types/vec.html"><strong aria-hidden="true">43.</strong> Vec</a></li><li class="chapter-item expanded "><a href="else-if-expressions/index.html"><strong aria-hidden="true">44.</strong> Else If Expressions</a></li><li class="chapter-item expanded "><a href="assignment-operators/index.html"><strong aria-hidden="true">45.</strong> Assignment Operators</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="assignment-operators/examples.html"><strong aria-hidden="true">45.1.</strong> Examples</a></li><li class="chapter-item expanded "><a href="assignment-operators/division.html"><strong aria-hidden="true">45.2.</strong> Division</a></li><li class="chapter-item expanded "><a href="assignment-operators/remainder.html"><strong aria-hidden="true">45.3.</strong> Remainder</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">46.</strong> Arithmetic Stuff</div></li><li class="chapter-item expanded affix "><li class="part-title">Original Versions</li><li class="chapter-item expanded "><a href="data-types/_index-old.html"><strong aria-hidden="true">47.</strong> Data Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="data-types/implicit-explicit.html"><strong aria-hidden="true">47.1.</strong> Implicit And Explicit</a></li><li class="chapter-item expanded "><a href="data-types/using-explicit-types.html"><strong aria-hidden="true">47.2.</strong> Using Explicit Types</a></li><li class="chapter-item expanded "><a href="data-types/the-number-types.html"><strong aria-hidden="true">47.3.</strong> The Number Types</a></li><li class="chapter-item expanded "><a href="data-types/booleans.html"><strong aria-hidden="true">47.4.</strong> Booleans</a></li></ol></li><li class="chapter-item expanded "><a href="compound-data-types/index.html"><strong aria-hidden="true">48.</strong> Compound Data Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="compound-data-types/tuples.html"><strong aria-hidden="true">48.1.</strong> Tuples</a></li><li class="chapter-item expanded "><a href="compound-data-types/tuple-indexes.html"><strong aria-hidden="true">48.2.</strong> Tuple Indexes</a></li><li class="chapter-item expanded "><a href="compound-data-types/indexes-and-offset.html"><strong aria-hidden="true">48.3.</strong> Indexes And Offsets</a></li></ol></li><li class="chapter-item expanded "><a href="functions/_index-old.html"><strong aria-hidden="true">49.</strong> Functions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="functions/parameters.html"><strong aria-hidden="true">49.1.</strong> Parameters</a></li><li class="chapter-item expanded "><a href="functions/using-parameters.html"><strong aria-hidden="true">49.2.</strong> Using Parameters</a></li><li class="chapter-item expanded "><a href="functions/multiple-parameters.html"><strong aria-hidden="true">49.3.</strong> Multiple Parameters</a></li><li class="chapter-item expanded "><a href="functions/using-multiple-parameters.html"><strong aria-hidden="true">49.4.</strong> Using Multiple Parameters</a></li><li class="chapter-item expanded "><a href="functions/return-values.html"><strong aria-hidden="true">49.5.</strong> Return Values</a></li><li class="chapter-item expanded "><a href="functions/binding-return-values.html"><strong aria-hidden="true">49.6.</strong> Binding Return Values</a></li><li class="chapter-item expanded "><a href="functions/return-expressions.html"><strong aria-hidden="true">49.7.</strong> Return Expressions</a></li><li class="chapter-item expanded "><a href="functions/return-expression-errors.html"><strong aria-hidden="true">49.8.</strong> Return Expression Errors</a></li><li class="chapter-item expanded "><a href="functions/review.html"><strong aria-hidden="true">49.9.</strong> Review</a></li></ol></li><li class="chapter-item expanded "><a href="if-expressions/index.html"><strong aria-hidden="true">50.</strong> if Expressions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="if-expressions/false-conditions.html"><strong aria-hidden="true">50.1.</strong> false Conditions</a></li><li class="chapter-item expanded "><a href="if-expressions/else-expressions.html"><strong aria-hidden="true">50.2.</strong> else Expressions</a></li><li class="chapter-item expanded "><a href="if-expressions/else-if-expressions.html"><strong aria-hidden="true">50.3.</strong> else if Expressions</a></li><li class="chapter-item expanded "><a href="if-expressions/multiple-if-else-expressions.html"><strong aria-hidden="true">50.4.</strong> Multiple if else Expressions</a></li><li class="chapter-item expanded "><a href="if-expressions/function-example.html"><strong aria-hidden="true">50.5.</strong> Function Example</a></li><li class="chapter-item expanded "><a href="if-expressions/binding-variables.html"><strong aria-hidden="true">50.6.</strong> Binding Variables</a></li><li class="chapter-item expanded "><a href="if-expressions/binding-values-must-be-the-same.html"><strong aria-hidden="true">50.7.</strong> Binding Values Must Be The Same</a></li><li class="chapter-item expanded "><a href="if-expressions/incompatible-types.html"><strong aria-hidden="true">50.8.</strong> Incompatible Types</a></li></ol></li><li class="chapter-item expanded "><a href="while-loops/_index-old.html"><strong aria-hidden="true">51.</strong> While Loops</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="while-loops/assignments.html"><strong aria-hidden="true">51.1.</strong> Assignments</a></li></ol></li><li class="chapter-item expanded "><a href="for-loops/_index_old.html"><strong aria-hidden="true">52.</strong> For Loops</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="for-loops/using-ranges.html"><strong aria-hidden="true">52.1.</strong> Using Ranges</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">53.</strong> if let placeholder</div></li><li class="chapter-item expanded affix "><li class="part-title">Cards</li><li class="chapter-item expanded "><a href="cards/error-messages-in-tutorials.html"><strong aria-hidden="true">54.</strong> Error Messages In Tutorials</a></li><li class="chapter-item expanded "><a href="introduction/messing-with-the-code.html"><strong aria-hidden="true">55.</strong> Messing With The Code</a></li><li class="chapter-item expanded "><a href="introduction/preamble.html"><strong aria-hidden="true">56.</strong> Preamble</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Stuff To Sort</li><li class="chapter-item expanded "><a href="the-string-type/index.html"><strong aria-hidden="true">57.</strong> The String Type</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="the-string-type/moving-strings.html"><strong aria-hidden="true">57.1.</strong> Moving String</a></li></ol></li><li class="chapter-item expanded "><a href="functions/_placeholder.html"><strong aria-hidden="true">58.</strong> Functions Placeholder</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="passing-values-in-funcitons/index.html"><strong aria-hidden="true">58.1.</strong> Passing Values In Functions</a></li><li class="chapter-item expanded "><a href="functions/references.html"><strong aria-hidden="true">58.2.</strong> Function References</a></li><li class="chapter-item expanded "><a href="functions/references-can-not-be-modified.html"><strong aria-hidden="true">58.3.</strong> Function References Can't Be Modified</a></li><li class="chapter-item expanded "><a href="functions/mutable-references.html"><strong aria-hidden="true">58.4.</strong> Function Mutable References</a></li><li class="chapter-item expanded "><a href="functions/only-one-mutable-reference.html"><strong aria-hidden="true">58.5.</strong> Only One Mutable Reference</a></li><li class="chapter-item expanded "><a href="functions/scope-for-mutable-refereces.html"><strong aria-hidden="true">58.6.</strong> Scope For Mutable References</a></li><li class="chapter-item expanded "><a href="functions/mutable-and-immutable-references-can-not-be-combined.html"><strong aria-hidden="true">58.7.</strong> Mutable And Immutable References Can't Be Combined</a></li><li class="chapter-item expanded "><a href="functions/_todo.html"><strong aria-hidden="true">58.8.</strong> TODO</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Needs Spell Check</li><li class="chapter-item expanded "><a href="slices/_todo.html"><strong aria-hidden="true">59.</strong> Slices TODO</a></li><li class="chapter-item expanded "><a href="string-literals/_todo.html"><strong aria-hidden="true">60.</strong> String literals</a></li><li class="chapter-item expanded "><a href="structs/_todo.html"><strong aria-hidden="true">61.</strong> Structs</a></li><li class="chapter-item expanded "><a href="tuple-structs/_todo.html"><strong aria-hidden="true">62.</strong> Tuple Structs</a></li><li class="chapter-item expanded "><a href="debug-derived-trait/_todo.html"><strong aria-hidden="true">63.</strong> Debug Derived Trait</a></li><li class="chapter-item expanded "><a href="struct-methods/_todo.html"><strong aria-hidden="true">64.</strong> Struct Methods</a></li><li class="chapter-item expanded "><a href="enums/_todo.html"><strong aria-hidden="true">65.</strong> Enums</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="enum-type-aliases/index.html"><strong aria-hidden="true">65.1.</strong> Enum Type Aliases</a></li></ol></li><li class="chapter-item expanded "><a href="match/_todo.html"><strong aria-hidden="true">66.</strong> match</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">To Sort</li><li class="chapter-item expanded "><a href="scope/index.html"><strong aria-hidden="true">67.</strong> Scope</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="scope/error.html"><strong aria-hidden="true">67.1.</strong> Scope Error</a></li><li class="chapter-item expanded "><a href="scope/error-message.html"><strong aria-hidden="true">67.2.</strong> Scope Error Message</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Misc</li><li class="chapter-item expanded "><a href="guidelines/index.html"><strong aria-hidden="true">68.</strong> Guildlines</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">-- Work In Progress --</li><li class="chapter-item expanded "><a href="dev/work-in-progress.html"><strong aria-hidden="true">69.</strong> Work In Progress</a></li><li class="chapter-item expanded "><a href="todo/index.html"><strong aria-hidden="true">70.</strong> TODO List</a></li><li class="chapter-item expanded "><a href="statements-and-expressions/index.html"><strong aria-hidden="true">71.</strong> Statements and Expressions</a></li><li class="chapter-item expanded "><a href="constants/index.html"><strong aria-hidden="true">72.</strong> Constants</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="constants/in-the-globa-scope.html"><strong aria-hidden="true">72.1.</strong> In The Global Scope</a></li><li class="chapter-item expanded "><a href="constants/types-required.html"><strong aria-hidden="true">72.2.</strong> Types Required</a></li><li class="chapter-item expanded "><a href="constants/compile-time.html"><strong aria-hidden="true">72.3.</strong> Compile Time</a></li></ol></li><li class="chapter-item expanded "><a href="shadowing-variables/index.html"><strong aria-hidden="true">73.</strong> Shadowing Variables</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="shadowing-variables/in-scope.html"><strong aria-hidden="true">73.1.</strong> Shadowing Variables In Scope</a></li><li class="chapter-item expanded "><a href="shadowing-variables/changing-type.html"><strong aria-hidden="true">73.2.</strong> Shadowing Variables To Change Type</a></li></ol></li><li class="chapter-item expanded "><a href="data-types/characters.html"><strong aria-hidden="true">74.</strong> Characters</a></li><li class="chapter-item expanded "><a href="todo/destructring-tuples.html"><strong aria-hidden="true">75.</strong> Destructuring Tuples</a></li><li class="chapter-item expanded "><a href="todo/adding-values-to-tuples.html"><strong aria-hidden="true">76.</strong> Adding Values To Tuples</a></li><li class="chapter-item expanded "><a href="compound-data-types/arrays.html"><strong aria-hidden="true">77.</strong> Arrays</a></li><li class="chapter-item expanded "><a href="functions/statements-and-expressions.html"><strong aria-hidden="true">78.</strong> Statements And Expressions</a></li><li class="chapter-item expanded "><a href="option-type/_todo.html"><strong aria-hidden="true">79.</strong> Option Type</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Work In Progress</li><li class="chapter-item expanded "><a href="prerequisites/index.html"><strong aria-hidden="true">80.</strong> Prerequisites</a></li><li class="chapter-item expanded "><a href="appendix/about.html"><strong aria-hidden="true">81.</strong> About This Site</a></li><li class="chapter-item expanded "><a href="glossary/index.html"><strong aria-hidden="true">82.</strong> Glossary</a></li><li class="chapter-item expanded "><a href="dev/typo-test.html"><strong aria-hidden="true">83.</strong> Typo Test</a></li><li class="chapter-item expanded "><a href="introduction/work-in-progress.html"><strong aria-hidden="true">84.</strong> Work In Progress</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="variables/turning-off-warnings.html"><strong aria-hidden="true">84.1.</strong> Turning Off Warnings</a></li><li class="chapter-item expanded "><a href="variables/immutable-variable-error.html"><strong aria-hidden="true">84.2.</strong> The Error Message</a></li></ol></li><li class="chapter-item expanded "><a href="error-messages/index.html"><strong aria-hidden="true">85.</strong> Error Messages</a></li><li class="chapter-item expanded "><a href="variables/original-with-types.html"><strong aria-hidden="true">86.</strong> Variables - Origian with types</a></li><li class="chapter-item expanded "><a href="if-let/index.html"><strong aria-hidden="true">87.</strong> if let</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">To Sort</li><li class="chapter-item expanded "><a href="loops/index.html"><strong aria-hidden="true">88.</strong> Loops</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="loops/binding-variables.html"><strong aria-hidden="true">88.1.</strong> Binding Values</a></li><li class="chapter-item expanded "><a href="loops/labels.html"><strong aria-hidden="true">88.2.</strong> Labels</a></li><li class="chapter-item expanded "><a href="loops/nested-loops.html"><strong aria-hidden="true">88.3.</strong> Nested Loops</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Holding</li><li class="chapter-item expanded affix "><li class="part-title">Fizz Buzz</li><li class="chapter-item expanded "><a href="fizz-buzz/index.html"><strong aria-hidden="true">89.</strong> Fizz Buzz</a></li><li class="chapter-item expanded affix "><li class="part-title">For Review</li><li class="chapter-item expanded "><a href="hello-world/the-parts.html"><strong aria-hidden="true">90.</strong> Hello, World - The Parts</a></li><li class="chapter-item expanded "><a href="hello-world/index.html"><strong aria-hidden="true">91.</strong> A Complete Program</a></li><li class="chapter-item expanded affix "><li class="part-title">Sandbox</li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <!--
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        -->
                    </div>

                    <h1 class="menu-title">Typing Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>


                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">


                    <main>
                        <!-- 
                        <div id="rawTextToCompare" style="display: none;">rawTextToCompare</div>
                        <div id="tmpLine">Templine<div>
                        <hr />
                        <div id="debugLine" style="color: red; font-family: monospace;"></div>
                        -->
                        <h1 id="welcome-to-typing-rust"><a class="header" href="#welcome-to-typing-rust">Welcome to Typing Rust</a></h1>
<p>Hi. I'm Alan and I'm building this site to
learn Rust.</p>
<p>The site has traditional pages and code samples
as well as two interactive features. The
first is a &quot;Step By Step&quot; explination
of the code examples. Each step some code
and provides an explination of what's happening.</p>
<p>Here's one with two steps for a program
that print out &quot;Hello, World&quot;.</p>
<h4 id="step-by-step"><a class="header" href="#step-by-step">Step By Step</a></h4>
<script>
const rawSourceCode = `fn main() {
  println!("Hello, World");
}

Hello, World`.split('\n')


const lineSets = [
{ 
  lines: [`0_r`, `0_r`, `0_r`, `0_e`, `0_o`],
  text: `<p>That code is a full program. It will compile, run, and output &quot;Hello, World&quot;</p>`
},
{ 
  lines: [`0_r`, `0_s`, `0_r`, `0_e`, `0_w`],
  text: `<p>Well start all our code samples with a <code>main</code> function like the one shown here.</p>`
},
{ 
  lines: [`0_c`, `0_r`, `0_c`, `0_e`, `0_w`],
  text: `<p>We'll use the <code>println!()</code> expression to output text from our programs. Here we add a line to print &quot;Hello, World&quot;.</p>`
},
]
</script>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-world---your-turn"><a class="header" href="#hello-world---your-turn">Hello, World - Your Turn</a></h1>
<p>I learn best by doing. For programming
that means typing code examples into an
editor. The second feature of the site
is designed to do just that. You'll find
Source Code blocks paired with
Code Runners editors across the site.
They let you enter and run the code without
having to install Rust yourself.</p>
<p>Typing slows me down in beneficial
ways. I focus more on the the code. That
helps me understand and remember how things
work. The approach can take some getting
used to. Stick with it for a bit to see if
you start to see the benefit.</p>
<p>Here's the first one. It's the same
&quot;Hello, World&quot; as the example on the prior
page. Type it in and run it to see the
output.</p>
<h3 id="source-code"><a class="header" href="#source-code">SOURCE CODE</a></h3>
<pre><code class="language-rust  noplayground  EXAMPLE1">fn main() {
  println!(&quot;Hello, World&quot;);
}</code></pre>
<h3 id="code-runner"><a class="header" href="#code-runner">CODE RUNNER</a></h3>
<pre><pre class="playground"><code class="language-rust  editable  CODE1"></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-status-line"><a class="header" href="#the-status-line">The Status Line</a></h1>
<p>Learning to read error message is a crital part of
programming. We'll cover them. But, hitting one
because you made a typo in a tutorail is a waste
of time, energy, and motivation.</p>
<p>You may have noticed the &quot;Status&quot; line in the
Code Runner on the previous pages. It's designed
to eliminate typos by highlighting them as soon as
they occur and show you what character to use.</p>
<p>If you've ever entered a huge block of tutorial
code only to be hit with an indecipherable error
because of an unrelated typo, you know why I built it.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quick-notes"><a class="header" href="#quick-notes">Quick Notes</a></h1>
<p>A few quick notes before we continue:</p>
<ul>
<li>
<p>This site is a work in progress. It's built from
my actual, in-progress notes. It only goes
as far as I've made it learning the language.</p>
</li>
<li>
<p>The content is designed for folks who have a little
programming experience. If you know what variables,
loops, conditionals, and functions are you'll be fine.</p>
</li>
<li>
<p>Examples are intentionally sort. That often
means doing things that would be silly in useful
programs. For example, defining a variable that's
used only once on the following line. The goal is to
show <em>how</em> to use something not <em>when</em> to use it.</p>
</li>
<li>
<p>The Code Runners have a &quot;Disable Status Line&quot; button.
Hit that to prevent the status line from warning you
about typos if you want to change code to play with the
code samples.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="variables"><a class="header" href="#variables">Variables</a></h1>
<p>Basic Rust variables are created using this
formula:</p>
<ol>
<li>The <code>let</code> keyword</li>
<li>A name</li>
<li>The <code>=</code> sign</li>
<li>The value</li>
<li>A <code>;</code> character</li>
</ol>
<p>The values for a string of text looks like this:
<code>String::from(&quot;apple&quot;)</code>. Using that and <code>alfa</code> for
the name we can create a variable like this:</p>
<pre><code class="language-rust noplayground">let alfa = String::from(&quot;apple&quot;);</code></pre>
<p>In Rust, setting variables is called &quot;binding&quot;.
So, the above line binds a <code>String</code> with the
text &quot;apple&quot; to the variable <code>alfa</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="printing-variables"><a class="header" href="#printing-variables">Printing Variables</a></h1>
<p>Most examples on the site print something.
We'll do that using <code>println!()</code>.</p>
<p><code>println!()</code> uses what are called &quot;format
strings&quot; as templates for output. Putting
the name of a variable inside <code>{}</code> curly brackets
in a format string outputs its value. For example,
if we have a variable named <code>alfa</code> we can print
it like this:</p>
<pre><code class="language-rust  noplayground">println!(&quot;alfa is {alfa}&quot;);</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="printing-variables---step-by-step"><a class="header" href="#printing-variables---step-by-step">Printing Variables - Step By Step</a></h1>
<p>Here's a program that creates a variable
the prints it out.</p>
<h4 id="step-by-step-1"><a class="header" href="#step-by-step-1">Step By Step</a></h4>
<script>
const rawSourceCode = `fn main() {
  let alfa = String::from("apple");
  println!("alfa is {alfa}");
}

alfa is apple`.split('\n')


const lineSets = [
{ 
  lines: [`0_r`, `0_r`,`0_r`,`0_r`, `0_c`, `0_o`],
  text: `<p>The output from the program is <code>alfa is apple</code></p>`
},
{ 
  lines: [`0_r`, `0_s`,`0_s`,`0_r`, `0_s`, `0_s`],
  text: `<p>We start out with an empty <code>main</code> function.</p>`
},
{ 
  lines: [`0_c`, `0_r`,`0_s`,`0_c`, `0_s`, `0_s`],
  text: `<p>The first step is to create a variable named <code>alfa</code> with a <code>String</code> containing &quot;apple&quot; bound to it</p>`
},
{ 
  lines: [`0_c`, `0_c`,`0_r`,`0_c`, `0_s`, `0_s`],
  text: `<p>Then we add the <code>println!()</code> statement that outputs the text of the <code>String</code> when the program is run</p>`
},

]

</script>
<!--

---

Here's a full program to demonstrate that. It
outputs:

```txt
alfa is apple
```

Give it a shot in the Code Runner:

### SOURCE CODE

```rust, noplayground, EXAMPLE1
fn main() {
  let alfa = String::from("apple");
  println!("alfa is {alfa}");
}
```

### CODE RUNNER

```rust, editable, CODE1

```

-->
<div style="break-before: page; page-break-before: always;"></div><h1 id="printing-variables---your-turn"><a class="header" href="#printing-variables---your-turn">Printing Variables - Your Turn</a></h1>
<p>Here's the same code to try yourself.</p>
<h3 id="source-code-1"><a class="header" href="#source-code-1">SOURCE CODE</a></h3>
<pre><code class="language-rust  noplayground  EXAMPLE1">fn main() {
  let alfa = String::from(&quot;apple&quot;);
  println!(&quot;alfa is {alfa}&quot;);
}</code></pre>
<h3 id="code-runner-1"><a class="header" href="#code-runner-1">CODE RUNNER</a></h3>
<pre><pre class="playground"><code class="language-rust  editable  CODE1"></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mutable-variables"><a class="header" href="#mutable-variables">Mutable Variables</a></h1>
<p>Rust variables are immutalbe by default. That means
you can't change them after they've been set. The
<code>mut</code> keyword makes them mutable allowing them
to be changed after they are created.</p>
<p>Here's an example of a standard immutable variable:</p>
<pre><code class="language-rust noplayground">let alfa = String::from(&quot;apple&quot;);</code></pre>
<p>And here's the same binding but with the <code>mut</code>
keyword that make the variable mutable.</p>
<pre><code class="language-rust noplayground">let mut alfa = String::from(&quot;apple&quot;);
    ↑↑↑</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mutable-variables---step-by-step"><a class="header" href="#mutable-variables---step-by-step">Mutable Variables - Step By Step</a></h1>
<p>One way to change a mutable <code>String</code> is to use
<code>.push_str()</code> to add characters
to the end of it. Here's what that looks like:</p>
<h4 id="step-by-step-2"><a class="header" href="#step-by-step-2">Step By Step</a></h4>
<script>
const rawSourceCode = `fn main() {
  let mut alfa = String::from("apple");
  alfa.push_str("pie");
  println!("alfa is {alfa}");
}

alfa is applepie`.split('\n')


const lineSets = [
{ 
  lines: [`0_r`, `0_r`,`0_r`,`0_r`, `0_r`, `0_e`, `0_o`],
  text: `<p>The output from the program is <code>alfa is applepie</code></p>`
},
{ 
  lines: [`0_r`, `0_s`,`0_s`, `0_s`, `0_r`, `0_e`, `0_w`],
  text: `<p>We start with the standard <code>mian</code> function</p>`,
},
{ 
  lines: [`0_c`, `0_r`,`0_s`, `0_s`,`0_c`, `0_e`, `0_w`],
  text: `<p>Use the <code>mut</code> keyword to create a mutable variable named <code>alfa</code> with a <code>String</code> of <code>apple</code> bound to it<p>`
},
{ 
  lines: [`0_c`, `0_c`,`0_r`, `0_s`,`0_c`, `0_e`, `0_w`],
  text: `<p>Next, add a <code>.push_str()</code> expression to push <code>pie</code> onto the end of the string</p>`
},
{ 
  lines: [`0_c`, `0_c`,`0_c`, `0_r`,`0_c`, `0_e`, `0_w`],
  text: `<p>The last step is to print output which shows use the value of the variable</p>`
},

]

</script>
<!--

---

Here's a full program to demonstrate that. It
outputs:

```txt
alfa is apple
```

Give it a shot in the Code Runner:

### SOURCE CODE

```rust, noplayground, EXAMPLE1
fn main() {
  let alfa = String::from("apple");
  println!("alfa is {alfa}");
}
```

### CODE RUNNER

```rust, editable, CODE1

```

-->
<!--

```txt
alfa is apple
alfa is apple-pie
```

### SOURCE CODE

```rust, noplayground, EXAMPLE1
fn main() {
  let mut alfa = String::from("apple");
  println!("alfa is {alfa}");

  alfa.push_str("-pie");
  println!("alfa is {alfa}");
}
```

### CODE RUNNER

```rust, editable, CODE1

```
-->
<div style="break-before: page; page-break-before: always;"></div><h1 id="mutable-variables---your-turn"><a class="header" href="#mutable-variables---your-turn">Mutable Variables - Your Turn</a></h1>
<h3 id="source-code-2"><a class="header" href="#source-code-2">SOURCE CODE</a></h3>
<pre><code class="language-rust  noplayground  EXAMPLE1">fn main() {
  let mut alfa = String::from(&quot;apple&quot;);
  alfa.push_str(&quot;pie&quot;);
  println!(&quot;alfa is {alfa}&quot;);
}</code></pre>
<h3 id="code-runner-2"><a class="header" href="#code-runner-2">CODE RUNNER</a></h3>
<pre><pre class="playground"><code class="language-rust  editable  CODE1"></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions"><a class="header" href="#functions">Functions</a></h1>
<p>Each program we make will have a <code>main()</code> funciton.
It's the first things that gets executed.</p>
<p>We can create other functions as well. We'll use
three types of functions with the following
properties:</p>
<ol>
<li>Does not accept arguments - Has no return value</li>
<li>Accepts arguments - Has no return value</li>
<li>Does not accept arguments - Does have a return value</li>
<li>Accepts arguments - Does have a return value</li>
</ol>
<p>The formulas for each of the three types are
on the next three pages. Don't worry too much
about memorizing them. We'll use each plenty
of times.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions-with-no-arguments-and-no-return-value"><a class="header" href="#functions-with-no-arguments-and-no-return-value">Functions With No Arguments And No Return Value</a></h1>
<p>The formula for functions that take no
arguments and return no values is:</p>
<ol>
<li>The <code>fn</code> keyword</li>
<li>A name</li>
<li>An empty set of <code>()</code> parenthesis</li>
<li>A set of <code>{}</code> curly brackets surrounding the function's code block</li>
</ol>
<p>For example:</p>
<pre><code class="language-rust noplayground">fn widget() {
  println!(&quot;this is widget&quot;);
}</code></pre>
<p>Calling functions without arguments is done using its
name followed by empty <code>()</code>, like:</p>
<pre><code class="language-rust  noplayground">widget();</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions---no-args-or-return-value---step-by-step"><a class="header" href="#functions---no-args-or-return-value---step-by-step">Functions - No Args Or Return Value - Step By Step</a></h1>
<p>Details</p>
<h4 id="step-by-step-3"><a class="header" href="#step-by-step-3">Step By Step</a></h4>
<script>
const rawSourceCode = `fn main() {
  widget();
}

fn widget() {
  println!("this is widget");
}

this is widget`.split('\n')


const lineSets = [
{ 
  lines: [`0_r`, `0_r`,`0_r`,`0_r`, `0_r`, `0_r`, `0_r`, `0_e`, `0_o`],
  text: `<p></p>`
},
{ 
  lines: [`0_s`, `0_s`,`0_s`,`0_s`, `0_r`, `0_s`, `0_r`, `0_e`, `0_w`],
  text: `<p>Create an empty <code>widget</code> function</p>`
},
{ 
  lines: [`0_s`, `0_s`,`0_s`,`0_s`, `0_c`, `0_r`, `0_c`, `0_e`, `0_w`],
  text: `<p>Add a <code>println!()</code> statement to create some output</p>`
},
{ 
  lines: [`0_r`, `0_s`,`0_r`,`0_s`, `0_c`, `0_c`, `0_c`, `0_e`, `0_w`],
  text: `<p>Create the <code>main</main> function</p>`
},
{ 
  lines: [`0_c`, `0_r`,`0_c`,`0_s`, `0_c`, `0_c`, `0_c`, `0_e`, `0_w`],
  text: `<p>Call the <code>widget()</code> function from main</p>`
},

]

</script>
<div style="break-before: page; page-break-before: always;"></div><h1 id="your-turn"><a class="header" href="#your-turn">Your Turn</a></h1>
<h3 id="source-code-3"><a class="header" href="#source-code-3">SOURCE CODE</a></h3>
<pre><code class="language-rust  noplayground  EXAMPLE1">fn main() {
  widget();
}

fn widget() {
  println!(&quot;this is widget&quot;);
}</code></pre>
<h3 id="code-runner-3"><a class="header" href="#code-runner-3">CODE RUNNER</a></h3>
<pre><pre class="playground"><code class="language-rust  editable  CODE1"></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions-that-take-arguments-but-have-no-return-value"><a class="header" href="#functions-that-take-arguments-but-have-no-return-value">Functions That Take Arguments But Have No Return Value</a></h1>
<p>The formula for functions that <em>do</em> take
arguments without returning a value is must
the same as functions that don't. The
difference is that the <code>()</code> parens are
populated to let the function know about
the incoming data</p>
<ol>
<li>The <code>fn</code> keyword</li>
<li>A name</li>
<li>Parenthesis with argument details. For example: <code>(thing: String)</code></li>
<li>A set of <code>{}</code> curly brackets surrounding the function's code block</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions-that-take-arguments-but-have-no-return-value---step-by-step"><a class="header" href="#functions-that-take-arguments-but-have-no-return-value---step-by-step">Functions That Take Arguments But Have No Return Value - Step By Step</a></h1>
<h4 id="step-by-step-4"><a class="header" href="#step-by-step-4">Step By Step</a></h4>
<script>
const rawSourceCode = `fn main() {
  let alfa = String::from("apple");
  widget(alfa);
}

fn widget(thing: String) { // fn widget(<code>thing: String</code>) { // fn widget() {
  println!("widget got {thing}");
}

widget got apple`.split('\n')


const lineSets = [
{ 
  lines: [`0_r`, `0_r`, `0_r`, `0_r`, `0_r`, `0_r`, `0_r`, `0_r`, `0_e`, `0_o`],
  text: `<p>When the <code>widget</code> function receives the value in <code>alfa</code> from <code>main</code> it prints the output</p>`
},
{ 
  lines: [`0_s`, `0_s`, `0_s`, `0_s`, `0_s`, `2_r`, `0_s`, `0_r`, `0_e`, `0_w`],
  text: `<p>Start by creating an empty <code>widget</code> function</p>`
},
{ 
  lines: [`0_s`, `0_s`, `0_s`, `0_s`, `0_s`, `1_u`, `0_s`, `0_c`, `0_e`, `0_w`],
  text: `<p>Update it to accept a <code>String</code> and bind it to the internal function variable <code>thing</code></p>`
},
{ 
  lines: [`0_s`, `0_s`, `0_s`, `0_s`, `0_s`, `0_c`, `0_r`, `0_c`, `0_e`, `0_w`],
  text: `<p>Setup <code>widget</code> to print out the <code>String</code> it receives in the <code>thing</code> variable</p>`
},
{ 
  lines: [`0_r`, `0_s`, `0_s`, `0_r`, `0_s`, `0_c`, `0_c`, `0_c`, `0_e`, `0_w`],
  text: `<p>Create the <code>main</code> function that's what gets called first when the program runs</p>`
},
{ 
  lines: [`0_c`, `0_r`, `0_s`, `0_r`, `0_s`, `0_c`, `0_c`, `0_c`, `0_e`, `0_w`],
  text: `<p>Create a variable named <code>alfa</code> inside <code>main</code> and bind a <code>String</code> of &quot;apple&quot; to it </p>`
},
{ 
  lines: [`0_c`, `0_c`, `0_r`, `0_c`, `0_s`, `0_c`, `0_c`, `0_c`, `0_e`, `0_w`],
  text: `<p>Call the <code>widget</code> function from <code>main</code> passing in the <code>alfa</code> variable as an argument</p>`
},
]
</script>
<div style="break-before: page; page-break-before: always;"></div><h1 id="your-turn-1"><a class="header" href="#your-turn-1">Your Turn</a></h1>
<h3 id="source-code-4"><a class="header" href="#source-code-4">SOURCE CODE</a></h3>
<pre><code class="language-rust  noplayground  EXAMPLE1">fn main() {
  let alfa = String::from(&quot;apple&quot;);
  widget(alfa);
}

fn widget(thing: String) {
  println!(&quot;widget got {thing}&quot;);
}</code></pre>
<h3 id="code-runner-4"><a class="header" href="#code-runner-4">CODE RUNNER</a></h3>
<pre><pre class="playground"><code class="language-rust  editable  CODE1"></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="takes-no-arguments-but-has-a-return-value"><a class="header" href="#takes-no-arguments-but-has-a-return-value">Takes No Arguments But Has A Return Value</a></h1>
<p>In addition to receiving data, functions can
also return values back to the code
that called them. Difining those functions is
done by adding <code>-&gt;</code> along what will be send back
behindg the parenthesis after the name. For example</p>
<pre><code class="language-rust noplayground">widget() -&gt; String</code></pre>
<p>The parts of the function look like this:</p>
<ol>
<li>The <code>fn</code> keyword</li>
<li>A name</li>
<li>An empty set of <code>()</code> parenthesis.</li>
<li>The <code>-&gt;</code> symbol followed by what type of data will be returned</li>
<li>A set of <code>{}</code> curly brackets surrounding the function's code block</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions-that-take-arguments-but-have-no-return-value---step-by-step-1"><a class="header" href="#functions-that-take-arguments-but-have-no-return-value---step-by-step-1">Functions That Take Arguments But Have No Return Value - Step By Step</a></h1>
<h4 id="step-by-step-5"><a class="header" href="#step-by-step-5">Step By Step</a></h4>
<script>
const rawSourceCode = `fn main() {
  let alfa = widget();
  println!("alfa got {alfa}");
}

fn widget() -> String { // fn widget() { 
  let bravo = String::from("berry");
  bravo
}

alfa got alfa`.split('\n')

const lineSets = [
{ 
  lines: [`0_r`, `0_r`, `0_r`, `0_r`, `0_r`, `0_r`, `0_r`, `0_r`, `0_r`, `0_e`, `0_o`],
  text: `<p></p>`
},
{ 
  lines: [`0_s`, `0_s`, `0_s`, `0_s`, `0_s`, `1_r`, `0_s`, `0_s`, `0_r`, `0_e`, `0_w`],
  text: `<p>Create an empty widget function</p>`
},
{ 
  lines: [`0_s`, `0_s`, `0_s`, `0_s`, `0_s`, `0_r`, `0_s`, `0_s`, `0_r`, `0_e`, `0_w`],
  text: `<p>Add the type of value <code>widget</code> will return</p>`
},
{ 
  lines: [`0_s`, `0_s`, `0_s`, `0_s`, `0_s`, `0_c`, `0_r`, `0_s`, `0_c`, `0_e`, `0_w`],
  text: `<p>Create a <code>bravo</code> variable in <code>widget</code> with the <code>String</code> to return from the function</p>`
},
{ 
  lines: [`0_s`, `0_s`, `0_s`, `0_s`, `0_s`, `0_c`, `0_c`, `0_r`, `0_c`, `0_e`, `0_w`],
  text: `<p>Return <code>bravo<code> by calling it as an expression by itself</p>`
},
{ 
  lines: [`0_r`, `0_s`, `0_s`, `0_r`, `0_s`, `0_c`, `0_c`, `0_c`, `0_c`, `0_e`, `0_w`],
  text: `<p>Create the main function</p>`
},
{ 
  lines: [`0_c`, `0_r`, `0_s`, `0_c`, `0_s`, `0_c`, `0_c`, `0_c`, `0_c`, `0_e`, `0_w`],
  text: `<p>Make an <code>alfa</code> variable in <code>main</code> that calls <code>widget</code> to get its return value to bind as the value</p>`
},
{ 
  lines: [`0_c`, `0_c`, `0_r`, `0_c`, `0_s`, `0_c`, `0_c`, `0_c`, `0_c`, `0_e`, `0_w`],
  text: `<p>Print <code>alfa</code> to verify the value came through properly</p>`
},
]
</script>
<div style="break-before: page; page-break-before: always;"></div><h1 id="your-turn-2"><a class="header" href="#your-turn-2">Your Turn</a></h1>
<h3 id="source-code-5"><a class="header" href="#source-code-5">SOURCE CODE</a></h3>
<pre><code class="language-rust  noplayground  EXAMPLE1">fn main() {
  let alfa = widget();
  println!(&quot;alfa got {alfa}&quot;);
}

fn widget() -&gt; String {
  let bravo = String::from(&quot;berry&quot;);
  bravo
}</code></pre>
<h3 id="code-runner-5"><a class="header" href="#code-runner-5">CODE RUNNER</a></h3>
<pre><pre class="playground"><code class="language-rust  editable  CODE1"></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions-that-take-arguments-and-have-return-values"><a class="header" href="#functions-that-take-arguments-and-have-return-values">Functions That Take Arguments And Have Return Values</a></h1>
<h4 id="step-by-step-6"><a class="header" href="#step-by-step-6">Step By Step</a></h4>
<script>
const rawSourceCode = `fn main() {
  let alfa = String::from("apple");
  let charlie = widget(alfa);
  println!("charlie is {charlie}");
}

fn widget(thing: String) -> String {
  println!("widget got {thing}");
  let bravo = String::from("berry");
  bravo
}`.split('\n')


const lineSets = [
{ 
  lines: [`0_r`, `0_r`, `0_r`, `0_r`, `0_r`, `0_r`, `0_r`, `0_r`, `0_r`, `0_r`, `0_r`],
  text: `<p></p>`
},
{ 
  lines: [`0_r`, `0_s`, `0_s`, `0_s`, `0_r`, `0_s`, `0_s`, `0_s`, `0_s`, `0_s`, `0_s`],
  text: `<p>The first step is to create the main function.</p>`
},
{ 
  lines: [`0_c`, `0_s`, `0_s`, `0_s`, `0_c`, `0_s`, `0_r`, `0_s`, `0_s`, `0_s`, `0_r`],
  text: `<p>Next, create a function named <code>widget</code> that accepts one argument</p>`
},
{ 
  lines: [`0_c`, `0_s`, `0_s`, `0_s`, `0_c`, `0_s`, `0_c`, `0_r`, `0_s`, `0_s`, `0_c`],
  text: `<p></p>`
},
{ 
  lines: [`0_c`, `0_s`, `0_s`, `0_s`, `0_c`, `0_s`, `0_c`, `0_c`, `0_r`, `0_s`, `0_c`],
  text: `<p></p>`
},
{ 
  lines: [`0_c`, `0_s`, `0_s`, `0_s`, `0_c`, `0_s`, `0_c`, `0_c`, `0_c`, `0_r`, `0_c`],
  text: `<p></p>`
},
{ 
  lines: [`0_c`, `0_r`, `0_s`, `0_s`, `0_c`, `0_s`, `0_c`, `0_c`, `0_c`, `0_c`, `0_c`],
  text: `<p></p>`
},
{ 
  lines: [`0_c`, `0_c`, `0_r`, `0_s`, `0_c`, `0_s`, `0_c`, `0_c`, `0_c`, `0_c`, `0_c`],
  text: `<p></p>`
},
{ 
  lines: [`0_c`, `0_c`, `0_c`, `0_r`, `0_c`, `0_s`, `0_c`, `0_c`, `0_c`, `0_c`, `0_c`],
  text: `<p></p>`
},
]
</script>
<div style="break-before: page; page-break-before: always;"></div><h1 id="your-turn-3"><a class="header" href="#your-turn-3">Your Turn</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ownership"><a class="header" href="#ownership">Ownership</a></h1>
<p><em>NOTE: This is my understanding of how ownership
based on The Rust Book. I need to have it vetted
by someone who knows more about Rust.</em></p>
<hr />
<p>A fundamental feature of Rust is that
every value has an &quot;owner&quot;. When we bind
a value to a variable like this:</p>
<pre><code class="language-rust noplayground">let alfa = String::from(&quot;apple&quot;);</code></pre>
<p>that variable becomes the owner of the value.
In the case that means <code>alfa</code> now owns the
<code>String</code> of &quot;apple&quot;. You can think of an &quot;owner&quot;
like a wrapper around the value.</p>
<p>As long as a varible is owner of a value it
can use it. For example, if we call this
after setting <code>alfa</code> like we did above:</p>
<pre><code class="language-rust noplayground">println!(&quot;alfa is {alfa}&quot;);</code></pre>
<p>it will output:</p>
<pre><code class="language-txt">alfa is apple
</code></pre>
<p>becuase <code>alfa</code> owns the <code>String</code> made
from &quot;apple&quot;.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="step-1"><a class="header" href="#step-1">Step 1</a></h1>
<p>Let's go through the process of creating a variable
and binding a value to it to get a better understading
of ownership. We'll start off by splitting this
line in half:</p>
<pre><code class="language-rust  noplayground">let alfa = String::from(&quot;apple&quot;);</code></pre>
<p>The <code>let alfa</code> on the left side of our equal sign
is what's responsible for creating the variable
with our specified name.</p>
<p><img src="ownership//images/ownership-1.png" alt="Ownership 1" /></p>
<p>Adding in the <code>String::from(&quot;apple&quot;)</code> to complete
the expression creates the value, binds it to
<code>alfa</code>, and makes <code>alfa</code> its owner in the process.</p>
<p><img src="ownership//images/ownership-2.png" alt="Ownership 2" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="step-2"><a class="header" href="#step-2">Step 2</a></h1>
<p>When we want to use the value of the <code>String</code> we
don't access it directly. We get it from through
the variable.</p>
<p>For exaple, if we do:</p>
<pre><code class="language-rust noplayground">println!(&quot;alfa has {alfa}&quot;);</code></pre>
<p>Rust sees the request for <code>alfa</code> and accesses
the variable to get the value it's bound to
and returns it for the output:</p>
<pre><code class="language-rust noplayground">alfa is apple</code></pre>
<p>Here's what that looks like:</p>
<p><img src="ownership//images/ownership-3.png" alt="Ownership 3" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="step-3"><a class="header" href="#step-3">Step 3</a></h1>
<p>Now let's make a new variable called
<code>bravo</code> and bind our exsiting <code>alfa</code>
variable to it.</p>
<p>As before, the <code>let bravo</code> on the
left side of the eaqual sign is what's
responsible for making the variable</p>
<p><img src="ownership//images/ownership-4.png" alt="Ownership 4" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="what-doesnt-happen"><a class="header" href="#what-doesnt-happen">What Doesn't Happen</a></h1>
<p>Next we'll complete our expression with this:</p>
<pre><code class="language-rust noplayground">let bravo = alfa;</code></pre>
<p>Becasue <code>alfa</code> became the owner of our <code>String</code> value
when we did this:</p>
<pre><code class="language-rust noplayground">let alfa = String::from(&quot;apple&quot;);</code></pre>
<p>It's natural to think <code>bravo</code> would become
the owner of <code>alfa</code> when we completed our
expression with <code>let bravo = alfa;</code></p>
<p>If that were the case, we'd get something
that looks like this:</p>
<p><img src="ownership//images/ownership-5.png" alt="Ownership 5" /></p>
<p>We would then be able to get at our <code>String</code>
value from both <code>alfa</code> and <code>bravo</code>. (<code>alfa</code>
would be direct and <code>bravo</code> would go through
<code>alfa</code>).</p>
<p>But, that's not what happens.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="step-4"><a class="header" href="#step-4">Step 4</a></h1>
<p>TODO: Can variables have owners? And does
this page use the right language?</p>
<hr />
<p>Let's look at what <em>does</em> happen starting with
a review of Step 3 where:</p>
<ol>
<li>The <code>alfa</code> variable has been created</li>
<li>The <code>String::from(&quot;apple&quot;)</code> value has
been created and bound to <code>alfa</code> making the
variable its owner</li>
<li>We've made the first half of the expression
to bind <code>alfa</code> to <code>bravo</code></li>
</ol>
<p>Our illustration looked like this:</p>
<p><img src="ownership//images/ownership-4.png" alt="Ownership 4" /></p>
<p>Now we can complete the expression with:</p>
<pre><code class="language-rust noplayground">let bravo = alfa;</code></pre>
<p>That assignment doesn't make <code>bravo</code> the
owner of <code>alfa</code>. Instead the value that's
insdie <code>alfa</code> gets moved into <code>bravo</code> and
<code>bravo</code> becomes the owner.</p>
<p><img src="ownership//images/ownership-6.png" alt="Ownership 6" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="step-5"><a class="header" href="#step-5">Step 5</a></h1>
<p>Using <code>bravo</code> gives us the <code>String</code> value
output of &quot;apple&quot; the same way <code>alfa</code> did
before the move.</p>
<p><img src="ownership//images/ownership-7.png" alt="Ownership 7" /></p>
<p>If we combine and run all the code we've
use so far everything works.</p>
<h3 id="source-code-6"><a class="header" href="#source-code-6">SOURCE CODE</a></h3>
<pre><code class="language-rust  noplayground  EXAMPLE1">fn main() {
  let alfa = String::from(&quot;apple&quot;);
  println!(&quot;alfa has {alfa}&quot;);

  let bravo = alfa;
  println!(&quot;bravo has {bravo}&quot;);
}</code></pre>
<h3 id="code-runner-6"><a class="header" href="#code-runner-6">CODE RUNNER</a></h3>
<pre><pre class="playground"><code class="language-rust  editable  CODE1"></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hitting-a-moved-error"><a class="header" href="#hitting-a-moved-error">Hitting A Moved Error</a></h1>
<p>Where things go wrong is if we try to
use <code>alfa</code> again. Values can only
have one owner. When we did <code>let bravo = alfa;</code>
it transferred ownership of the <code>String</code> from
<code>alfa</code> to <code>bravo</code>.</p>
<p>Without ownership, <code>alfa</code> can't work with the
<code>String</code> any more`</p>
<p>Trying to use it looks like this:</p>
<p><img src="ownership//images/ownership-8.png" alt="Ownership 8" /></p>
<p>Here's the full example of the code where
we try to access <code>alfa</code> with this line</p>
<pre><code class="language-rust  noplayground">println!(&quot;alfa has {alfa}&quot;);</code></pre>
<p>Since the <code>String</code> was moved to <code>bravo</code>
we get an error that we'll discuss next.</p>
<h3 id="source-code-7"><a class="header" href="#source-code-7">SOURCE CODE</a></h3>
<pre><code class="language-rust  noplayground  EXAMPLE1">fn main() {
  let alfa = String::from(&quot;apple&quot;);
  let bravo = alfa;

  println!(&quot;alfa has {alfa}&quot;);
}</code></pre>
<h3 id="code-runner-7"><a class="header" href="#code-runner-7">CODE RUNNER</a></h3>
<pre><pre class="playground"><code class="language-rust  editable  CODE1"></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="moving-error-details"><a class="header" href="#moving-error-details">Moving Error Details</a></h1>
<p>TKTKTKT - Write up the details of
this error.</p>
<p>This is the error.</p>
<pre><code class="language-rust  noplayground">   Compiling playground v0.0.1 (/playground)
error[E0382]: borrow of moved value: `alfa`
 --&gt; src/main.rs:8:23
  |
2 |   let alfa = String::from(&quot;apple&quot;);
  |       ---- move occurs because `alfa` has type `String`, which does not implement the `Copy` trait
...
5 |   let bravo = alfa;
  |               ---- value moved here
...
8 |   println!(&quot;alfa has {alfa}&quot;);
  |                       ^^^^ value borrowed here after move
  |
  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)
help: consider cloning the value if the performance cost is acceptable
  |
5 |   let bravo = alfa.clone();
  |                   ++++++++

For more information about this error, try `rustc --explain E0382`.
error: could not compile `playground` due to previous error</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="references"><a class="header" href="#references">References</a></h1>
<p>References offer a way to access a value
from multiple variables without changing
ownership. They're made by putting the
<code>&amp;</code> symbol in front of the original
variable that holds the value.</p>
<p>For example this code moves ownership of the
<code>String</code> on the <code>bravo = alfa</code> line.</p>
<pre><code class="language-rust noplayground">  let alfa  = String::from(&quot;apple&quot;);
  let bravo = alfa;</code></pre>
<p>If we tried to access <code>alfa</code> after doing
that we'd get the <code>borrow of moved value</code>
error.</p>
<p>Adding the <code>&amp;</code> like this means the
value isn't moved to <code>bravo</code> and
that <code>alfa</code> retains ownership.</p>
<pre><code class="language-rust noplayground">  let alfa  = String::from(&quot;apple&quot;);
  let bravo = &amp;alfa;</code></pre>
<p>We can now use the value from
both variables.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="example"><a class="header" href="#example">Example</a></h1>
<p>Here's an example using a reference that
outputs: </p>
<pre><code class="language-txt">alfa is apple
bravo is apple
</code></pre>
<h3 id="source-code-8"><a class="header" href="#source-code-8">SOURCE CODE</a></h3>
<pre><code class="language-rust  noplayground  EXAMPLE1">fn main() {
  let alfa = String::from(&quot;apple&quot;);
  let bravo = &amp;alfa;

  println!(&quot;alfa is {alfa}&quot;);
  println!(&quot;bravo is {bravo}&quot;);
}</code></pre>
<h3 id="code-runner-8"><a class="header" href="#code-runner-8">CODE RUNNER</a></h3>
<pre><pre class="playground"><code class="language-rust  editable  CODE1"></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="step-1-1"><a class="header" href="#step-1-1">Step 1</a></h1>
<p>The first step is to create an initial
variable with the standard line:</p>
<pre><code class="language-rust noplayground">let alfa = String::from(&quot;apple&quot;);</code></pre>
<p>We'll use a slightly different illustration
this time where the <code>String</code> value has
as side exposed.</p>
<p><img src="references//images/references-1.png" alt="References Illustration" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="step-2-1"><a class="header" href="#step-2-1">Step 2</a></h1>
<p>Now we can create our reference with the <code>&amp;</code>
character like this:</p>
<pre><code class="language-rust  noplayground">let bravo = &amp;alfa;</code></pre>
<p>We'll represent the reference this way where
<code>alfa</code> still owns the <code>String</code> but <code>bravo</code>
is connected to it as well.</p>
<p><img src="references//images/references-2.png" alt="References Illustration" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="working-example"><a class="header" href="#working-example">Working Example</a></h1>
<p>Here's a refined version of our previous example
that didn't work:</p>
<pre><code class="language-rust noplayground">fn main() {
  let alfa = String::from(&quot;apple&quot;);
  let bravo = alfa;

  println!(&quot;alfa has {alfa}&quot;);
  println!(&quot;bravo has {bravo}&quot;);
}</code></pre>
<p>We can get the code working with a reference
by changing the line</p>
<pre><code class="language-rust  noplayground">let bravo = alfa;</code></pre>
<p>to:</p>
<pre><code class="language-rust  noplayground">let bravo = &amp;alfa;</code></pre>
<p>Here's the full sample which outputs:</p>
<pre><code class="language-txt">alfa has apple
bravo has apple
</code></pre>
<h3 id="source-code-9"><a class="header" href="#source-code-9">SOURCE CODE</a></h3>
<pre><code class="language-rust  noplayground  EXAMPLE1">fn main() {
  let alfa = String::from(&quot;apple&quot;);
  let bravo = &amp;alfa;

  println!(&quot;alfa has {alfa}&quot;);
  println!(&quot;bravo has {bravo}&quot;);
}</code></pre>
<h3 id="code-runner-9"><a class="header" href="#code-runner-9">CODE RUNNER</a></h3>
<pre><pre class="playground"><code class="language-rust  editable  CODE1"></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="multiple-references"><a class="header" href="#multiple-references">Multiple References</a></h1>
<p>Variables are immutalbe by default. So are
references. One benefit of that since we
can be sure they won't change we can add
as many references as we like.</p>
<p>Here's an illustration using two new
variables <code>charlie</code> and <code>delta</code> that
reference the original <code>alfa</code> value.</p>
<p><img src="references//images/references-3.png" alt="References Illustration" /></p>
<p>And here's the code showing it working. It
outputs:</p>
<pre><code class="language-txt">alfa has apple
bravo has apple
charlie has apple
delta has apple
</code></pre>
<h3 id="source-code-10"><a class="header" href="#source-code-10">SOURCE CODE</a></h3>
<pre><code class="language-rust  noplayground  EXAMPLE1">fn main() {
  let alfa = String::from(&quot;apple&quot;);
  let bravo = &amp;alfa;
  let charlie = &amp;alfa;
  let delta = &amp;alfa;

  println!(&quot;alfa has {alfa}&quot;);
  println!(&quot;bravo has {bravo}&quot;);
  println!(&quot;charlie has {charlie}&quot;);
  println!(&quot;delta has {delta}&quot;);
}</code></pre>
<h3 id="code-runner-10"><a class="header" href="#code-runner-10">CODE RUNNER</a></h3>
<pre><pre class="playground"><code class="language-rust  editable  CODE1"></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="function-argument-references"><a class="header" href="#function-argument-references">Function Argument References</a></h1>
<p>References are required to send the
value of a variable to a function and
still be able to use the original variable
afterwards.</p>
<p>That looks like this:</p>
<h3 id="source-code-11"><a class="header" href="#source-code-11">SOURCE CODE</a></h3>
<pre><code class="language-rust  noplayground  EXAMPLE1">fn main() {
  let alfa = String::from(&quot;apple&quot;);
  widget(&amp;alfa);
  println!(&quot;alfa is {alfa}&quot;);
}

fn widget(thing: &amp;String) {
  println!(&quot;widget got {thing}&quot;);
}</code></pre>
<h3 id="code-runner-11"><a class="header" href="#code-runner-11">CODE RUNNER</a></h3>
<pre><pre class="playground"><code class="language-rust  editable  CODE1"></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="with-variables"><a class="header" href="#with-variables">With Variables</a></h1>
<p>We can also create a reference in a new
variable the send it to the function.
Since we'll define the new varaible
as a refernce like this:</p>
<pre><code class="language-rust noplayground">let bravo = &amp;alfa</code></pre>
<p>We don't need to send it to use <code>&amp;</code> to
make it a reference again when we send
it to the <code>widget()</code> function. That is,
instead of this:</p>
<pre><code class="language-rust noplayground">widget(&amp;bravo);</code></pre>
<p>We do this:</p>
<pre><code class="language-rust noplayground">widget(bravo);</code></pre>
<p>Here'e the code:</p>
<h3 id="source-code-12"><a class="header" href="#source-code-12">SOURCE CODE</a></h3>
<pre><code class="language-rust  noplayground  EXAMPLE1">fn main() {
  let alfa = String::from(&quot;apple&quot;);
  let bravo = &amp;alfa;

  widget(bravo);

  println!(&quot;alfa is {alfa}&quot;);
  println!(&quot;bravo is {bravo}&quot;);
}

fn widget(thing: &amp;String) {
  println!(&quot;widget got {thing}&quot;);
}</code></pre>
<h3 id="code-runner-12"><a class="header" href="#code-runner-12">CODE RUNNER</a></h3>
<pre><pre class="playground"><code class="language-rust  editable  CODE1"></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-example"><a class="header" href="#error-example">Error Example</a></h1>
<p>Here's the same thing, but without <code>&amp;</code> which
shows the error.</p>
<h3 id="source-code-13"><a class="header" href="#source-code-13">SOURCE CODE</a></h3>
<pre><code class="language-rust  noplayground  EXAMPLE1">fn main() {
  let alfa = String::from(&quot;apple&quot;);
  println!(&quot;call widget next&quot;);

  widget(alfa);
  println!(&quot;alfa is {alfa}&quot;);
}

fn widget(value: String) {
  println!(&quot;widget got {value}&quot;);
}</code></pre>
<h3 id="code-runner-13"><a class="header" href="#code-runner-13">CODE RUNNER</a></h3>
<pre><pre class="playground"><code class="language-rust  editable  CODE1"></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mutable-function-argument-references"><a class="header" href="#mutable-function-argument-references">Mutable Function Argument References</a></h1>
<p>TKTKTKT</p>
<p>TODO: Explain this line by line</p>
<h3 id="source-code-14"><a class="header" href="#source-code-14">SOURCE CODE</a></h3>
<pre><code class="language-rust  noplayground  EXAMPLE1">fn main() {
  let mut alfa = String::from(&quot;apple&quot;);
  widget(&amp;mut alfa);
  println!(&quot;alfa is {alfa}&quot;);
}

fn widget(value: &amp;mut String) {
  value.push_str(&quot;-pie&quot;);
}</code></pre>
<h3 id="code-runner-14"><a class="header" href="#code-runner-14">CODE RUNNER</a></h3>
<pre><pre class="playground"><code class="language-rust  editable  CODE1"></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="prototype-1"><a class="header" href="#prototype-1">Prototype 1</a></h1>
<h2 id="source-code-15"><a class="header" href="#source-code-15">Source Code</a></h2>
<div id="codeOutput"></div>
<script src="/scripts/prototype-1.js"></script>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scratchpad"><a class="header" href="#scratchpad">Scratchpad</a></h1>
<h2 id="step-by-step-7"><a class="header" href="#step-by-step-7">Step By Step</a></h2>
<script>
const rawSourceCode = `fn main() {
  let alfa = String::from("apple");
  show_value(&alfa);
  println!("alfa is {alfa}");
}

fn show_value(value: &String) { 
  println!("show_value got {value}");
}`.split('\n')


const lineSets = [
{ lines: [],
text: ""
},
{ lines: [`0_r`, `0_s`,`0_s`,`0_s`,`0_r`,`0_s`,`0_s`,`0_s`,`0_s`,],
text: "<p>here 1</p>"
},
{ lines: [`0_c`, `0_s`,`0_s`,`0_s`,`0_c`,`0_s`,`0_r`,`0_s`,`0_r`,],
text: "<p>here 1</p>"
},
{ lines: [`0_c`, `0_s`,`0_s`,`0_s`,`0_c`,`0_s`,`0_c`,`0_r`,`0_c`,],
text: "<p>here 1</p>"
},
{ lines: [`0_c`, `0_r`,`0_s`,`0_s`,`0_c`,`0_s`,`0_c`,`0_c`,`0_c`,],
text: "<p>here 1</p>"
},
{ lines: [`0_c`, `0_c`,`0_r`,`0_s`,`0_c`,`0_s`,`0_c`,`0_c`,`0_c`,],
text: "<p>here 1</p>"
},
{ lines: [`0_c`, `0_c`,`0_c`,`0_r`,`0_c`,`0_s`,`0_c`,`0_c`,`0_c`,],
text: "<p>here 1</p>"
},
{ lines: [`0_c`, `0_c`,`0_c`,`0_c`,`0_c`,`0_s`,`0_c`,`0_c`,`0_c`,],
text: "<p>here</p>"
}
]
</script>
<h2 id="step-by-step-test"><a class="header" href="#step-by-step-test">Step By Step Test</a></h2>
<p>This is the first prototype of the viewer.
Next step is to highlight lines that changed.</p>
<script>
let alfa_step = 0;

const renderCode = (code, lines) => {
  document.createElement("div");
  console.log('here');
  // const loc = document.getElementById('source-code');
  const loc = window['source-code'];
  console.log(loc);
}


const alfa_code = `
fn main() {
  let mut alfa = String::from("apple");
  widget(&mut alfa);
  println!("alfa is {alfa}");
}

fn widget(thing: &mut String) {
  thing.push_str("pie");
}

/// Temp stuff below

fn widget() {

`.split("\n");

const alfa_lines = [
  [1, 5, 6, 13, 9], 
  [1, 2, 5, 6, 13, 9], 
  [1, 2, 3, 5, 6, 13, 9], 
  [1, 2, 3, 5, 6, 7, 9], 
  [1, 2, 3, 5, 6, 7, 8, 9], 
  [1, 2, 3, 4, 5, 6, 7, 8, 9], 
]

const alfa_text = [
  `<p>Start with empty <code>main</code> and <code>widget</code>
  functions</p>`,
  `<p>Create a mutable <code>alfa</code> varaible bound to 
  our <code>String</code></p>`,
  `<p>Add a call to the <code>widget</code> function using
  with a mutable reference to <code>alfa</code> as an argument.
  </p>`,
  `<p>Update the <code>widget</code> function to accept the
  mutable refernce and bind it to a local variable named
  <code>thing</code></p>`,
  `<p>Make an update to the refernce</p>`,
  `<p>Output the value of <code>alfa</code> to show it's changed<p>`
]



const goToPrevious = () => {
  if (alfa_step > 0) {
    alfa_step -= 1
    updateStepByStep(alfa_step)
  }
}

const goToNext = () => {
  console.log(`goToNext incoming alfa_step: ${alfa_step}`)
  if (alfa_step < alfa_lines.length - 1) {
    alfa_step += 1
    updateStepByStep(alfa_step)
  }
}

const updateStepByStep = () => {
  const outputLines = [];
  for (let line_id in alfa_lines[alfa_step]) {
    outputLines.push(alfa_code[alfa_lines[alfa_step][line_id]])
  }
  window.stepByStepCode.value = outputLines.join("\n")

  window.stepByStepText.innerHTML = alfa_text[alfa_step]

  if (alfa_step > 0) {
    window.previousButton.innerHTML = "Previous"
  } else {
    window.previousButton.innerHTML = "&nbsp;&nbsp;----&nbsp;&nbsp;"
  }
  if (alfa_step < alfa_lines.length - 1) {
    window.nextButton.innerHTML = "Next"
  } else {
    window.nextButton.innerHTML = "&nbsp;--&nbsp;"
  }
}

const updateFromIndividualButton = (event) => {
  const indexToSwitchTo = parseInt(event.target.id.split("--")[1])
  console.log(indexToSwitchTo)
  alfa_step = indexToSwitchTo
  updateStepByStep()
}

const setupStepByStep = () => {

  const stepByStepButtonRowEl = document.createElement("div")

  const previousStepButtonEl = document.createElement('button')
  previousStepButtonEl.innerHTML = "&nbsp;&nbsp;&nbsp;--&nbsp;&nbsp;&nbsp;"
  previousStepButtonEl.id = "previousButton"
  stepByStepButtonRowEl.append(previousStepButtonEl)


  //stepByStepButtonEl.innerHTML = `<button id="previousButton">&nbsp;&nbsp;----&nbsp;&nbsp;</button>
  //<button id="nextButton">Next</button>`

  // const individualButtonRowEl = document.createElement("div")

  for (let i=0; i<alfa_lines.length; i ++) {
    const individualButtonEl = document.createElement("button")
    individualButtonEl.innerHTML = i + 1
    individualButtonEl.id = `individualStep--${i}`
    stepByStepButtonRowEl.append(individualButtonEl)
    individualButtonEl.addEventListener("click", updateFromIndividualButton)
  }

  const nextStepButtonEl = document.createElement('button')
  nextStepButtonEl.innerHTML = "Next"
  nextStepButtonEl.id = "nextButton"
  stepByStepButtonRowEl.append(nextStepButtonEl)

  const outputLines = [];
  for (let indx in alfa_lines[0]) {
    outputLines.push(alfa_code[alfa_lines[0][indx]])
  }

  const stepByStepCodeEl = document.createElement("textarea")
  stepByStepCodeEl.id = `stepByStepCode`
  stepByStepCodeEl.cols = 70
  stepByStepCodeEl.value = outputLines.join("\n");


  const stepByStepTextEl = document.createElement("div")
  stepByStepTextEl.id = "stepByStepText"
  stepByStepTextEl.innerHTML = alfa_text[0]

  window["stepByStepDiv"].append(stepByStepCodeEl);
  window["stepByStepDiv"].append(stepByStepTextEl);
  window["stepByStepDiv"].append(stepByStepButtonRowEl);
  // window["stepByStepDiv"].append(individualButtonRowEl);
   window["previousButton"].addEventListener("click", goToPrevious)
   window["nextButton"].addEventListener("click", goToNext)
   setStepByStepCodeRowCount()
}

const setStepByStepCodeRowCount = () => {
  window.stepByStepCode.rows = 1
  for (let lineIndex in alfa_lines) {
    if (window.stepByStepCode.rows < alfa_lines[lineIndex].length) {
      window.stepByStepCode.rows = alfa_lines[lineIndex].length
    }
  }
}

document.addEventListener("DOMContentLoaded", setupStepByStep);

</script>
<div id="stepByStepDiv"></div>
<hr />
<p>NOTE: These are in reverse order of how they were
created so I don't have to keep scrolling down</p>
<p>TODO: Come up with the list of things you can do
for references:</p>
<p>immutable - immutable
mutable - immutable
mutable - mutable</p>
<p>and that you can't do</p>
<p>immutable - mutable</p>
<h2 id="immutable---immutable"><a class="header" href="#immutable---immutable">Immutable -&gt; Immutable</a></h2>
<pre><pre class="playground"><code class="language-rust">fn main() {
  let alfa = String::from(&quot;apple&quot;);
  widget(&amp;alfa);
  println!(&quot;alfa is {alfa}&quot;)
}

fn widget(value: &amp;String) {
  println!(&quot;widget got {value}&quot;)
}</code></pre></pre>
<h2 id="mutable---mutable"><a class="header" href="#mutable---mutable">Mutable -&gt; Mutable</a></h2>
<pre><pre class="playground"><code class="language-rust">fn main() {
  let mut alfa = String::from(&quot;apple&quot;);
  widget(&amp;mut alfa);
  println!(&quot;alfa is {alfa}&quot;);
}

fn widget(value: &amp;mut String) {
  value.push_str(&quot;-pie&quot;)
}</code></pre></pre>
<h2 id="mutable---immutable"><a class="header" href="#mutable---immutable">Mutable -&gt; Immutable</a></h2>
<pre><pre class="playground"><code class="language-rust">fn main() {
  let mut alfa = String::from(&quot;apple&quot;);
  widget(&amp;alfa);
  println!(&quot;alfa is {alfa}&quot;)
}

fn widget(value: &amp;String) {
  println!(&quot;widget got {value}&quot;)
}</code></pre></pre>
<h2 id="immutable---mutable-will-crash"><a class="header" href="#immutable---mutable-will-crash">Immutable -&gt; Mutable (will crash)</a></h2>
<pre><pre class="playground"><code class="language-rust">fn main() {
  let alfa = String::from(&quot;apple&quot;);
  widget(&amp;mut alfa);
}

fn widget(value: &amp;mut String) {
  println!(&quot;widget got {value}&quot;)
}</code></pre></pre>
<hr />
<h2 id="this-crashes-as-expected-because-its-not-a-reference"><a class="header" href="#this-crashes-as-expected-because-its-not-a-reference">This crashes as expected because it's not a reference</a></h2>
<pre><pre class="playground"><code class="language-rust">fn main() {
  let alfa = String::from(&quot;apple&quot;);
  widget(alfa);
  println!(&quot;alfa is {alfa}&quot;)
}

fn widget(value: String) {
  println!(&quot;widget got {value}&quot;)
}</code></pre></pre>
<hr />
<p>Other situaltions:</p>
<p>combinging mutalbe and immutable
references.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="function-moves"><a class="header" href="#function-moves">Function Moves</a></h1>
<p>Using a variable as an argument
to a function applies the same type
of ownership move. This works right
now because we don't try to access
<code>alfa</code> again after sending it
to the function.</p>
<h3 id="source-code-16"><a class="header" href="#source-code-16">SOURCE CODE</a></h3>
<pre><code class="language-rust  noplayground  EXAMPLE1">fn main() {
  let alfa = String::from(&quot;apple&quot;);
  widget(alfa);
}

fn widget(value: String) {
  println!(&quot;widget got {value}&quot;);
}</code></pre>
<h3 id="code-runner-15"><a class="header" href="#code-runner-15">CODE RUNNER</a></h3>
<pre><pre class="playground"><code class="language-rust  editable  CODE1"></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="function-move-errors"><a class="header" href="#function-move-errors">Function Move Errors</a></h1>
<p>However, if we try to use <code>alfa</code>
again by adding this line it'll
break with the same type of error
as before.</p>
<pre><code class="language-rust noplayground">println!(&quot;alfa has {alfa}&quot;);</code></pre>
<h3 id="source-code-17"><a class="header" href="#source-code-17">SOURCE CODE</a></h3>
<pre><code class="language-rust  noplayground  EXAMPLE1">fn main() {
  let alfa = String::from(&quot;apple&quot;);
  widget(alfa);

  println!(&quot;alfa has {alfa}&quot;);
}

fn widget(value: String) {
  println!(&quot;widget got {value}&quot;);
}</code></pre>
<h3 id="code-runner-16"><a class="header" href="#code-runner-16">CODE RUNNER</a></h3>
<pre><pre class="playground"><code class="language-rust  editable  CODE1"></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="if-expressions"><a class="header" href="#if-expressions">if Expressions</a></h1>
<p><code>if</code> expressions are used to determine
if a section of code should be run or not.
They are created with:</p>
<ol>
<li>The <code>if</code> keyword</li>
<li>A condition to check</li>
<li>A block of code to run if the condition is true.</li>
</ol>
<p>The condition in the example below checks to see if the
number <code>3</code> is less than the number <code>4</code> using the <code>&lt;</code> math
symbol like this:</p>
<pre><code class="language-rust noplayground">3 &lt; 4</code></pre>
<p>Since the <code>3</code> <strong>is</strong> less than <code>4</code> the condition is
true so we'll see the output <code>the condition is true</code>.</p>
<h3 id="source-code-18"><a class="header" href="#source-code-18">SOURCE CODE</a></h3>
<pre><code class="language-rust  noplayground  EXAMPLE1">fn main() {
  if 3 &lt; 4 {
    println!(&quot;the condition is true&quot;);
  }
}</code></pre>
<h3 id="code-runner-17"><a class="header" href="#code-runner-17">CODE RUNNER</a></h3>
<pre><pre class="playground"><code class="language-rust  editable  CODE1"></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ifelse"><a class="header" href="#ifelse">If/Else</a></h1>
<p>We can provide an alternate block of code to run for
situations where the condition in the <code>if</code> expression
is not <code>true</code>. This is done with an <code>else</code> expression.</p>
<p>The below example checks to see if <code>8</code> is less than <code>7</code> with:</p>
<pre><code class="language-rust noplayground">8 &lt; 7</code></pre>
<p>That's not a true statement so <code>if</code> sees the condition
as <code>false</code>. Since <code>if</code> only runs its code block if
the condition is <code>true</code> it gets passed over. The
code in the <code>else</code> block is run instead and we see
the output:</p>
<pre><code class="language-txt">the condition is false
</code></pre>
<h3 id="source-code-19"><a class="header" href="#source-code-19">SOURCE CODE</a></h3>
<pre><code class="language-rust  noplayground  EXAMPLE1">fn main() {

  if 8 &lt; 7 {
    println!(&quot;the condition is true&quot;);
  } else {
    println!(&quot;the condition is false&quot;);
  }

}</code></pre>
<h3 id="code-runner-18"><a class="header" href="#code-runner-18">CODE RUNNER</a></h3>
<pre><pre class="playground"><code class="language-rust  editable  CODE1"></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="comparison-operators"><a class="header" href="#comparison-operators">Comparison Operators</a></h1>
<p>We used <code>&lt;</code> to check if one number was
less than another like this:</p>
<pre><code class="language-rust noplayground">if 1 &lt; 2 {
  println!(&quot;The comparison is true&quot;);
}</code></pre>
<p>The <code>&lt;</code> symbol is called an &quot;operator&quot;. It
performs a comparison operation and give
us a result.</p>
<p>The <code>&lt;</code> looks the same as you see it
in everyday math. Some of the other
comparison operators look a little different:</p>
<div class="table-wrapper"><table><thead><tr><th>Operator</th><th>Description</th></tr></thead><tbody>
<tr><td>&lt;</td><td>Less than</td></tr>
<tr><td>&lt;=</td><td>Less than or equal to</td></tr>
<tr><td>&gt;</td><td>Greater than</td></tr>
<tr><td>&gt;=</td><td>Greater than or equal to</td></tr>
<tr><td>==</td><td>Equal to</td></tr>
<tr><td>!=</td><td>Not equal to</td></tr>
</tbody></table>
</div>
<p>Here's what using <code>==</code> to check if two
numbers have the same value looks like:</p>
<h4 id="source-code-20"><a class="header" href="#source-code-20">SOURCE CODE</a></h4>
<pre><code class="language-rust  noplayground  EXAMPLE1">fn main() {

  if 7 == 8 {
    println!(&quot;They match&quot;);
  } else {
    println!(&quot;They don't match&quot;);
  }

}</code></pre>
<h3 id="code-runner-19"><a class="header" href="#code-runner-19">CODE RUNNER</a></h3>
<pre><pre class="playground"><code class="language-rust  editable  CODE1"></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="variables-with-if-expressions"><a class="header" href="#variables-with-if-expressions">Variables With If Expressions</a></h1>
<p>Let's use variables in the condition section
of our if/else expression. The first step is to
bind the values to our variables.</p>
<pre><code class="language-rust noplayground">let alfa = 7;
let bravo = 8;</code></pre>
<p>Then, we'll replace the numbers in the <code>condition</code>
section of the <code>if</code> statement with the variable
names. So, this:</p>
<pre><code class="language-rust noplayground">if 7 == 8 {
  ...
}</code></pre>
<p>Becomes this:</p>
<pre><code class="language-rust noplayground">if alfa == bravo {
  ...
}</code></pre>
<p>Here's the code for the full example which
outputs:</p>
<pre><code class="language-txt">They don't match
</code></pre>
<h3 id="source-code-21"><a class="header" href="#source-code-21">SOURCE CODE</a></h3>
<pre><code class="language-rust  noplayground  EXAMPLE1">fn main() {

  let alfa = 7;
  let bravo = 8;

  if alfa == bravo {
    println!(&quot;They match&quot;);
  } else {
    println!(&quot;They don't match&quot;);
  }

}</code></pre>
<h3 id="code-runner-20"><a class="header" href="#code-runner-20">CODE RUNNER</a></h3>
<pre><pre class="playground"><code class="language-rust  editable  CODE1"></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="println-variables"><a class="header" href="#println-variables">println! Variables</a></h1>
<p>Binding values to variables let us use them
repeatedly. For example, we can improve the
output of our program by including the
numbers that match or don't match.</p>
<p>We'll do this by using the variables in
<code>println!()</code> the same way we have before.
The only difference this time is that
we're putting two variables in the format
string instead of one.</p>
<h4 id="source-code-22"><a class="header" href="#source-code-22">SOURCE CODE</a></h4>
<pre><code class="language-rust  noplayground  EXAMPLE1">fn main() {

  let alfa = 7;
  let bravo = 8;

  if alfa == bravo {
    println!(&quot;{alfa} matches {bravo}&quot;);
  } else {
    println!(&quot;{alfa} does not match {bravo}&quot;);
  }

}</code></pre>
<h3 id="code-runner-21"><a class="header" href="#code-runner-21">CODE RUNNER</a></h3>
<pre><pre class="playground"><code class="language-rust  editable  CODE1"></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="data-types"><a class="header" href="#data-types">Data Types</a></h1>
<p>Rust has &quot;data types&quot;. Each one defines a different
kind of data. Every value in Rust has to fit
into one of those types. For example, numbers
without decimal points have a type of <code>i32</code>.</p>
<p>One way to think about it is like asking someone
what kind of dog they have.</p>
<pre><code class="language-txt">What kind of dog is Charlie?

A golden retriever
</code></pre>
<p>We can ask a similar question about values in Rust:</p>
<pre><code class="language-txt">What type of variable is alfa?

An i32
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-i32-type"><a class="header" href="#the-i32-type">The i32 Type</a></h1>
<p>The first type we'll talk about is <code>i32</code>.
It's a number without decimal places.
We've been using it without calling its
type out by name.</p>
<p>When we need to think about types we
can now say that we're binding an
<code>i32</code> value of <code>7</code> to the varailbe
name <code>alfa</code></p>
<h4 id="source-code-23"><a class="header" href="#source-code-23">SOURCE CODE</a></h4>
<pre><code class="language-rust  noplayground  EXAMPLE1">fn main() {
  let alfa = 7;
  println!(&quot;alfa is {alfa}&quot;);
}</code></pre>
<h3 id="code-runner-22"><a class="header" href="#code-runner-22">CODE RUNNER</a></h3>
<pre><pre class="playground"><code class="language-rust  editable  CODE1"></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="function-arguments"><a class="header" href="#function-arguments">Function Arguments</a></h1>
<p>Functions can receive values from other parts
of the program when they are called.</p>
<p>To do this, Rust needs to know what type of
vaule the function can accept. We
specify that in the <code>()</code> parenthesis that
follow the functions name in the definition.</p>
<p>For our example, we'll use:</p>
<pre><code class="language-rust noplayground">(value: i32)</code></pre>
<p><code>value</code> is a variable name that the
incoming parameter gets bound to inside
the function. That's followed by a <code>:</code>
that acts as a separator and then
the type of value the function expects
(<code>i32</code> in this case).</p>
<p>To use this, we'll change our function
from:</p>
<pre><code class="language-rust noplayground">fn alfa() {
  ...
}</code></pre>
<p>To</p>
<pre><code class="language-rust noplayground">fn alfa(value: i32) {
  ...
}</code></pre>
<p>Sending a value to the function is done
by putting it inside the <code>()</code> parenthesis
when after the name of the fuction in the
call.</p>
<p>So this:</p>
<pre><code class="language-rust noplayground">alfa();</code></pre>
<p>Becomes this when we pass the value <code>7</code>
(which is an <code>i32</code>)</p>
<pre><code class="language-rust noplayground">alfa(7);</code></pre>
<p>Here's a full version of the program that
outputs:</p>
<pre><code class="language-txt">call alfa next
alfa got 7
</code></pre>
<h4 id="source-code-24"><a class="header" href="#source-code-24">SOURCE CODE</a></h4>
<pre><code class="language-rust  noplayground  EXAMPLE1">fn main() {
  println!(&quot;call alfa next&quot;);
  alfa(7);
}

fn alfa(value: i32) {
  println!(&quot;alfa got {value}&quot;);
}</code></pre>
<h3 id="code-runner-23"><a class="header" href="#code-runner-23">CODE RUNNER</a></h3>
<pre><pre class="playground"><code class="language-rust  editable  CODE1"></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="program-conditional-functions"><a class="header" href="#program-conditional-functions">Program: Conditional Functions</a></h1>
<p>We've covered a lot of gound: variables,
if/else, comparison operators, functions, and
the <code>i32</code> data type. Each of the examples we
used was scoped down as much as possible to
focuse on just the concept at hand. Now,
let's write a larger program with everything
we've learned that does a little more.</p>
<p>Here's what we'll end up with:</p>
<ul>
<li>A <code>check_numbers</code> function that takes two
<code>i32</code> values.</li>
<li>An <code>if/else</code> expression that determines if the
first value is less than the seond</li>
<li><code>println!()</code> outputs that use the values</li>
<li>A set of <code>i32</code> variables in our <code>main</code> function</li>
<li>Calls to the <code>check_numbers</code> function with
the sets of variables.</li>
</ul>
<p>Here's the source which outputs:</p>
<pre><code class="language-txt">4 is less than 9
7 is not less than 3
</code></pre>
<h4 id="source-code-25"><a class="header" href="#source-code-25">SOURCE CODE</a></h4>
<pre><code class="language-rust  noplayground  EXAMPLE1">fn main() {
  let alfa = 4;
  let bravo = 9;
  check_numbers(alfa, bravo);

  let charlie = 7;
  let delta = 3;
  check_numbers(charlie, delta);
}

fn check_numbers(value1: i32, value2: i32) {
  if value1 &lt; value2 {
    println!(&quot;{value1} is less than {value2}&quot;);
  } else {
    println!(&quot;{value1} is not less than {value2}&quot;);
  }
}
</code></pre>
<h3 id="code-runner-24"><a class="header" href="#code-runner-24">CODE RUNNER</a></h3>
<pre><pre class="playground"><code class="language-rust  editable  CODE1"></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="immutable-variables"><a class="header" href="#immutable-variables">Immutable Variables</a></h1>
<p>Our Contional Function program uses four variables:</p>
<pre><code class="language-rust  noplayground">let alfa = 4;
let bravo = 9;</code></pre>
<p>and</p>
<pre><code class="language-rust  noplayground">let charlie = 7;
let delta = 3;</code></pre>
<p>Another approach is to change the values
of <code>alfa</code> and <code>bravo</code> instead of creating <code>charlie</code> and
<code>delta</code>. We can do that, but we need to change
the way we create <code>alfa</code> and <code>bravo</code> first because
Rust variables are <code>immutalbe</code> by default. That means
that once we bind a value to them we can't change it.</p>
<p>For example, run this and you'll get an error that
we'll discuss on the next page.</p>
<h3 id="source-code-26"><a class="header" href="#source-code-26">SOURCE CODE</a></h3>
<pre><code class="language-rust  noplayground  EXAMPLE1">fn main() {
  let alfa = 7;
  println!(&quot;alfa is {}&quot;, alfa);

  alfa = 9;
  println!(&quot;alfa is {}&quot;, alfa);
}</code></pre>
<h3 id="code-runner-25"><a class="header" href="#code-runner-25">CODE RUNNER</a></h3>
<pre><pre class="playground"><code class="language-rust  editable  CODE1"></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="assigning-twice-error"><a class="header" href="#assigning-twice-error">Assigning Twice Error</a></h1>
<p>When we created a variable with:</p>
<pre><code class="language-rust  noplayground">let alfa = 7;</code></pre>
<p>and then tried to change it's value with this:</p>
<pre><code class="language-rust  noplayground">alfa = 9;</code></pre>
<p>We got this error:</p>
<pre><code class="language-rust  noplayground">   Compiling playground v0.0.1 (/playground)
error[E0384]: cannot assign twice to immutable variable `alfa`
 --&gt; src/main.rs:6:3
  |
3 |   let alfa = 7;
  |       ----
  |       |
  |       first assignment to `alfa`
  |       help: consider making this binding mutable: `mut alfa`
...
6 |   alfa = 9;
  |   ^^^^^^^^ cannot assign twice to immutable variable

For more information about this error, try `rustc --explain E0384`.
error: could not compile `playground` due to previous error</code></pre>
<p>Rust's error messages are verbose, but great. They give us
nice, direct statements about what's wrong. Take this line from
our error.</p>
<pre><code class="language-rust  noplayground">error[E0384]: cannot assign twice to immutable variable `alfa`</code></pre>
<p>We made a first assignment to <code>alfa</code> in this default way
which make it immutable:</p>
<pre><code class="language-rust  noplayground">let alfa = 7;</code></pre>
<p>Later, we tried to update the value in the variable by
assining <code>9</code> to it like this.</p>
<pre><code class="language-rust  noplayground">alfa = 9;</code></pre>
<p>Rust won't let us do that since <code>alfa</code> is immutalbe so we get
that error message which tells us what's happening.</p>
<p>Something that's great about Rust is that error messages often
contian recommendations on how to fix what went wrong. Take
this line for example:</p>
<pre><code class="language-rust  noplayground">help: consider making this binding mutable: `mut alfa`</code></pre>
<p>It suggestions not only that we make <code>alfa</code> mutable, but it
also shows up how.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mutable-variables-1"><a class="header" href="#mutable-variables-1">Mutable Variables</a></h1>
<p>Rust variables are immutalbe by default. That means
you can't change them after they've been set. The
<code>mut</code> keyword makes them mutable allowing them
to be changed after they are created.</p>
<p>Here's an example of a standard immutable variable:</p>
<pre><code class="language-rust noplayground">let alfa = String::from(&quot;apple&quot;);</code></pre>
<p>And here's the same binding but with the <code>mut</code>
keyword that make the variable mutable.</p>
<pre><code class="language-rust noplayground">let mut alfa = String::from(&quot;apple&quot;);
    ↑↑↑</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="program-conditional-functions-v2"><a class="header" href="#program-conditional-functions-v2">Program: Conditional Functions V2</a></h1>
<p>Here's a minor update to our function to use
mutalbe variables by changing this:</p>
<pre><code class="language-rust noplayground">let alfa = 4;
let bravo = 9;
check_numbers(alfa, bravo);

let charlie = 7;
let delta = 3;
check_numbers(charlie, delta);</code></pre>
<p>To this:</p>
<pre><code class="language-rust noplayground">let mut alfa = 4;
let mut bravo = 9;
check_numbers(alfa, bravo);

alfa = 7;
bravo = 3;
check_numbers(alfa, bravo);</code></pre>
<h4 id="source-code-27"><a class="header" href="#source-code-27">SOURCE CODE</a></h4>
<pre><code class="language-rust  noplayground  EXAMPLE1">fn main() {
  let mut alfa = 4;
  let mut bravo = 9;
  check_numbers(alfa, bravo);

  alfa = 7;
  bravo = 3;
  check_numbers(alfa, bravo);
}

fn check_numbers(value1: i32, value2: i32) {
  if value1 &lt; value2 {
    println!(&quot;{value1} is less than {value2}&quot;);
  } else {
    println!(&quot;{value1} is not less than {value2}&quot;);
  }
}
</code></pre>
<h3 id="code-runner-26"><a class="header" href="#code-runner-26">CODE RUNNER</a></h3>
<pre><pre class="playground"><code class="language-rust  editable  CODE1"></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="for-loops"><a class="header" href="#for-loops">For Loops</a></h1>
<p>Rust has <code>for</code> loops which allow us to run the same
block of code multiple times.</p>
<p>The formula for a <code>for</code> loop that runs through a range
of numbers is:</p>
<ol>
<li>The <code>for</code> keyword</li>
<li>A variable name to hold the value of the number on each loop</li>
<li>The <code>in</code> keyword</li>
<li>The range of numbers</li>
<li>The code block to run each time though the loop</li>
</ol>
<p>The <code>range</code> has the format of:</p>
<ol>
<li>The starting number</li>
<li>Two dots followed by an equal sign (i.e. <code>..=</code>)</li>
<li>The ending number</li>
</ol>
<p>For example:</p>
<pre><code class="language-rust  noplayground">1..=5</code></pre>
<p>And here's a full example that outputs:</p>
<pre><code class="language-txt">alfa is 1
alfa is 2
alfa is 3
alfa is 4
alfa is 5
</code></pre>
<h4 id="source-code-28"><a class="header" href="#source-code-28">SOURCE CODE</a></h4>
<pre><code class="language-rust  noplayground  EXAMPLE1">fn main() {
  for alfa in 1..=5 {
    println!(&quot;alfa is {alfa}&quot;);
  }
}</code></pre>
<h3 id="code-runner-27"><a class="header" href="#code-runner-27">CODE RUNNER</a></h3>
<pre><pre class="playground"><code class="language-rust  editable  CODE1"></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="with-variables-1"><a class="header" href="#with-variables-1">With Variables</a></h1>
<p>We can also use variables for the
starting and ending numbers of the
range. Instead of:</p>
<pre><code class="language-rust noplayground">1..=5</code></pre>
<p>We set <code>start</code> and <code>end</code> variables then
use them with:</p>
<pre><code class="language-rust noplayground">start..=end</code></pre>
<p>Here's the updated version that also outputs:</p>
<pre><code class="language-txt">alfa is 1
alfa is 2
alfa is 3
alfa is 4
alfa is 5
</code></pre>
<h3 id="source-code-29"><a class="header" href="#source-code-29">SOURCE CODE</a></h3>
<pre><code class="language-rust  noplayground  EXAMPLE1">fn main() {

  let start = 1;
  let end = 5;

  for alfa in start..=end {
    println!(&quot;alfa is {alfa}&quot;);
  }

}</code></pre>
<h3 id="code-runner-28"><a class="header" href="#code-runner-28">CODE RUNNER</a></h3>
<pre><pre class="playground"><code class="language-rust  editable  CODE1"></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="arithmetic-operators"><a class="header" href="#arithmetic-operators">Arithmetic Operators</a></h1>
<p>Rust lets you do math through <code>arithmetic operators</code>. They are:</p>
<div class="table-wrapper"><table><thead><tr><th>Operator</th><th>Description</th></tr></thead><tbody>
<tr><td>+</td><td>Addition</td></tr>
<tr><td>-</td><td>Subtraction</td></tr>
<tr><td>*</td><td>Multiplication</td></tr>
<tr><td>/</td><td>Division</td></tr>
<tr><td>%</td><td>Remainder</td></tr>
</tbody></table>
</div>
<p>Addition, subtraction, and multiplication all work the
way you'd expect on <code>i32</code> numbers. For example, this
will give us values of <code>9</code>, <code>-1</code>, and <code>20</code> for the
three variables.</p>
<h4 id="source-code-30"><a class="header" href="#source-code-30">SOURCE CODE</a></h4>
<pre><code class="language-rust  noplayground  EXAMPLE1">fn main() {
  let alfa = 4 + 5;
  let bravo = 4 - 5;
  let charlie = 4 * 5;

  println!(&quot;alfa is {}&quot;, alfa);
  println!(&quot;bravo is {}&quot;, bravo);
  println!(&quot;charlie is {}&quot;, charlie);
}</code></pre>
<h3 id="code-runner-29"><a class="header" href="#code-runner-29">CODE RUNNER</a></h3>
<pre><pre class="playground"><code class="language-rust  editable  CODE1"></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="division-operator"><a class="header" href="#division-operator">Division Operator</a></h1>
<p>When used with <code>i32</code> type values the <code>/</code>
operator for division works differently
than you might expect. For example,
dividing <code>9</code> by <code>2</code> on a calculator
yields <code>4.5</code>. Since <code>i32</code> values don't
have decimal points we only get the
portion on the left side.</p>
<p>Running this will output:</p>
<pre><code class="language-txt">alfa is 4
</code></pre>
<h3 id="source-code-31"><a class="header" href="#source-code-31">SOURCE CODE</a></h3>
<pre><code class="language-rust  noplayground  EXAMPLE1">fn main() {
  let alfa = 9 / 2;
  println!(&quot;alfa is {}&quot;, alfa);
}</code></pre>
<h3 id="code-runner-30"><a class="header" href="#code-runner-30">CODE RUNNER</a></h3>
<pre><pre class="playground"><code class="language-rust  editable  CODE1"></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="remainder-operator"><a class="header" href="#remainder-operator">Remainder Operator</a></h1>
<p>The remainder operator gives us the value
that's left over after putting one
number into another as many times as
possible. (TODO: Look up the math
term for this)</p>
<p>For example, <code>2</code> goes into <code>9</code> four times
with a remainder of <code>1</code>. So, this code
outputs:</p>
<pre><code class="language-txt">alfa is 1
</code></pre>
<h3 id="source-code-32"><a class="header" href="#source-code-32">SOURCE CODE</a></h3>
<pre><code class="language-rust  noplayground  EXAMPLE1">fn main() {
  let alfa = 9 % 2;
  println!(&quot;alfa is {alfa}&quot;);
}</code></pre>
<h3 id="code-runner-31"><a class="header" href="#code-runner-31">CODE RUNNER</a></h3>
<pre><pre class="playground"><code class="language-rust  editable  CODE1"></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="arithmetic-operators-with-comparison-operators"><a class="header" href="#arithmetic-operators-with-comparison-operators">Arithmetic Operators With Comparison Operators</a></h1>
<p>The value returned by an arithmetic expressoin
can be used to set a value like we've already
seen:</p>
<pre><code class="language-rust  noplayground">let alfa = 4 + 9;</code></pre>
<p>They can also be used directly as one half
of an <code>if</code> expression with a conditional
operator.</p>
<p>For example, instead of:</p>
<pre><pre class="playground"><code class="language-rust  noplaygound"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if 7 &lt; 10 {
  ...
}
<span class="boring">}</span></code></pre></pre>
<p>We could do:</p>
<pre><pre class="playground"><code class="language-rust  noplaygound"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if 3 + 4 &lt; 10 {
  ...
}
<span class="boring">}</span></code></pre></pre>
<p>We could even use arithmetic operations on both
sides of the <code>=</code> sign like this example that
outputs:</p>
<pre><code class="language-txt">is the value more?
no
</code></pre>
<h3 id="source-code-33"><a class="header" href="#source-code-33">SOURCE CODE</a></h3>
<pre><code class="language-rust  noplayground  EXAMPLE1">fn main() {
  println!(&quot;is the value more?&quot;);
  if 3 + 4 &gt; 5 + 5 {
    println!(&quot;yes&quot;);
  } else {
    println!(&quot;no&quot;);
  }
}</code></pre>
<h3 id="code-runner-32"><a class="header" href="#code-runner-32">CODE RUNNER</a></h3>
<pre><pre class="playground"><code class="language-rust  editable  CODE1"></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="comparison-operators-with-variables"><a class="header" href="#comparison-operators-with-variables">Comparison Operators With Variables</a></h1>
<p>We can also use variables for the values
to compare.</p>
<pre><code class="language-txt">is the value less?
no
</code></pre>
<h3 id="source-code-34"><a class="header" href="#source-code-34">SOURCE CODE</a></h3>
<pre><code class="language-rust  noplayground  EXAMPLE1">fn main() {
  let alfa = 7;
  let bravo = 3;
  let charlie = 9;

  println!(&quot;is {alfa} + {bravo} less than {charlie}?&quot;);

  if alfa + bravo &lt; charlie {
    println!(&quot;yes&quot;);
  } else {
    println!(&quot;no&quot;);
  }
}</code></pre>
<h3 id="code-runner-33"><a class="header" href="#code-runner-33">CODE RUNNER</a></h3>
<pre><pre class="playground"><code class="language-rust  editable  CODE1"></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-the-remainder"><a class="header" href="#using-the-remainder">Using The Remainder</a></h1>
<p>The <code>%</code> remainder operator is surprigingly useful
in combination with the comparison operators. One
example is using it to divide content into
groups.</p>
<p>For exmaple, if we use <code>%</code> with an incrementing
number on the left side and <code>3</code> on the right side
it will return zero for everything that's
divisible by three with no remainder. If we
run a comparison against that value in an
if statement we can process every third value
differently.</p>
<p>Take this code for example that outputs:</p>
<pre><code class="language-txt">1 &lt;----
2 &lt;----
----&gt; 3
4 &lt;----
5 &lt;----
----&gt; 6
7 &lt;----
8 &lt;----
----&gt; 9
10 &lt;----
</code></pre>
<h3 id="source-code-35"><a class="header" href="#source-code-35">SOURCE CODE</a></h3>
<pre><code class="language-rust noplayground  EXAMPLE1">fn main() {
  let start = 1;
  let end = 10;
  let target = 3;

  for alfa in start..=end {
    if alfa % target == 0 {
      println!(&quot;----&gt; {alfa}&quot;)
    } else {
      println!(&quot;{alfa} &lt;----&quot;)
    }
  }
}</code></pre>
<h3 id="code-runner-34"><a class="header" href="#code-runner-34">CODE RUNNER</a></h3>
<pre><pre class="playground"><code class="language-rust  editable  CODE1"></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-the-remainder-v2"><a class="header" href="#using-the-remainder-v2">Using The Remainder V2</a></h1>
<p>Here's the same thing, but using <code>4</code> for
the value on the right side:</p>
<p>The output changes from:</p>
<pre><code class="language-txt">1 &lt;----
2 &lt;----
----&gt; 3
4 &lt;----
5 &lt;----
----&gt; 6
7 &lt;----
8 &lt;----
----&gt; 9
10 &lt;----
</code></pre>
<p>To:</p>
<pre><code class="language-txt">1 &lt;----
2 &lt;----
3 &lt;----
----&gt; 4
5 &lt;----
6 &lt;----
7 &lt;----
----&gt; 8
9 &lt;----
10 &lt;----
</code></pre>
<p>To this by just chaning the single target number
from <code>3</code> to <code>4</code>.</p>
<h3 id="source-code-36"><a class="header" href="#source-code-36">SOURCE CODE</a></h3>
<pre><code class="language-rust noplayground EXAMPLE1">fn main() {
  let start = 1;
  let end = 10;
  let target = 4;

  for alfa in start..=end {
    if alfa % target == 0 {
      println!(&quot;----&gt; {alfa}&quot;)
    } else {
      println!(&quot;{alfa} &lt;----&quot;)
    }
  }
}</code></pre>
<h3 id="code-runner-35"><a class="header" href="#code-runner-35">CODE RUNNER</a></h3>
<pre><pre class="playground"><code class="language-rust  editable  CODE1"></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="booleans"><a class="header" href="#booleans">Booleans</a></h1>
<p>We've used a bunch of <code>i32</code> type values. It's
time to introduce our next data type: <code>bool</code></p>
<p>The <code>bool</code> data type stands for boolean.
A value that can be either <code>true</code> or
<code>false</code> and nothing else.</p>
<p>Boolean values are bound to variables like
this:</p>
<pre><code class="language-rust noplayground">let alfa = true;
let bravo = false;</code></pre>
<p>The <code>if</code> statements we've been using
check to see if the condition is <code>true</code>
or not. We can use <code>bool</code> values</p>
<h4 id="source-code-37"><a class="header" href="#source-code-37">SOURCE CODE</a></h4>
<pre><code class="language-rust  noplayground  EXAMPLE1">fn main() {
  let mut alfa = true;
  let mut counter = 1;

  while alfa == true {
    println!(&quot;counter is {}&quot;, counter);
    if counter == 5 {
      alfa = false;
    }
    counter = counter + 1;
  }
}</code></pre>
<h3 id="code-runner-36"><a class="header" href="#code-runner-36">CODE RUNNER</a></h3>
<pre><pre class="playground"><code class="language-rust  editable  CODE1"></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="in-conditionals"><a class="header" href="#in-conditionals">In Conditionals</a></h1>
<p><code>if</code> statements check a condition to see
if it's true or false. We've been using
expressions like <code>3 &lt; 4</code> for as those
conditions. We can also use <code>bool</code> type
variables.</p>
<p>For example, this binds the <code>bool</code> value
<code>false</code> to the <code>alfa</code> variable then uses
it as the condition in the <code>if</code> statement.</p>
<p>The output is:</p>
<pre><code class="language-txt">alfa is false
</code></pre>
<h4 id="source-code-38"><a class="header" href="#source-code-38">SOURCE CODE</a></h4>
<pre><code class="language-rust  noplayground  EXAMPLE1">fn main() {
  let alfa = false;

  if alfa {
    println!(&quot;alfa is true&quot;);
  } else {
    println!(&quot;alfa is false&quot;);
  }
}</code></pre>
<h3 id="code-runner-37"><a class="header" href="#code-runner-37">CODE RUNNER</a></h3>
<pre><pre class="playground"><code class="language-rust  editable  CODE1"></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="function-return-values"><a class="header" href="#function-return-values">Function Return Values</a></h1>
<p>We've set up functions to receive argumets
by putting a name and type inside the
parenthesis after the function name:</p>
<pre><code class="language-rust noplayground">fn alfa(value: i32) {
  println!(&quot;alfa got {}&quot;, value);
}</code></pre>
<p>So far, all the functions have printed
something out when called. Now we'll
get them to return data to whatever
called them. Setting that up is done by adding
<code>-&gt;</code> after the parenthesis followed by
the type of data that will be returned.</p>
<p>The data that gets returned is generated
by the last expression in the function's
code block. For example, this <code>double_number</code>
function takes an <code>i32</code> value and multiplies
it by <code>2</code> as it's sending it back.</p>
<h4 id="source-code-39"><a class="header" href="#source-code-39">SOURCE CODE</a></h4>
<pre><code class="language-rust  noplayground  EXAMPLE1">fn main(){
  let alfa = double_number(5);
  println!(&quot;alfa is {}&quot;, alfa);
}

fn double_number(value: i32) -&gt; i32 {
  value * 2
}</code></pre>
<h3 id="code-runner-38"><a class="header" href="#code-runner-38">CODE RUNNER</a></h3>
<pre><pre class="playground"><code class="language-rust  editable  CODE1"></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="different-types"><a class="header" href="#different-types">Different Types</a></h1>
<p>Here's another look at the privous function:</p>
<pre><code class="language-rust  noplayground">fn double_number(value: i32) -&gt; i32 {
  value * 2
}</code></pre>
<p>It takes an <code>i32</code>:</p>
<pre><code class="language-rust noplayground">double_number(value: i32)</code></pre>
<p>And returns an <code>i32</code>:</p>
<pre><code class="language-rust noplayground">-&gt; i32</code></pre>
<p>The input type and the output type
don't have to match. In fact, return
values can be sent from functions
that don't receive any arguments.
Here we create a function that
takes no arguments and always
returns <code>true</code>.</p>
<h4 id="source-code-40"><a class="header" href="#source-code-40">SOURCE CODE</a></h4>
<pre><code class="language-rust  noplayground  EXAMPLE1">fn main() {

  let alfa = get_true();
  println!(&quot;alfa is {}&quot;, alfa);

}

fn get_true() -&gt; bool {

  true

}</code></pre>
<h3 id="code-runner-39"><a class="header" href="#code-runner-39">CODE RUNNER</a></h3>
<pre><pre class="playground"><code class="language-rust  editable  CODE1"></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="returning-from-if"><a class="header" href="#returning-from-if">Returning From if</a></h1>
<p>A function that always returns
<code>true</code> isn't particually useful. A
more realistic example is a function
that returns <code>true</code> based on some
condition. This example uses
a function to determine if a value
is above 5.</p>
<h4 id="source-code-41"><a class="header" href="#source-code-41">SOURCE CODE</a></h4>
<pre><code class="language-rust  noplayground  EXAMPLE1">fn main() {

  let alfa = 7;
  let bravo = is_over_five(alfa);

  println!(&quot;{} is over five? {}&quot;, alfa, bravo);

}

fn is_over_five(value: i32) -&gt; bool {

  if value &gt; 5 {
    true
  } else {
    false
  }

}</code></pre>
<h3 id="code-runner-40"><a class="header" href="#code-runner-40">CODE RUNNER</a></h3>
<pre><pre class="playground"><code class="language-rust  editable  CODE1"></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions-as-conditions"><a class="header" href="#functions-as-conditions">Functions As Conditions</a></h1>
<p>We can use the return values as conditions:</p>
<h4 id="source-code-42"><a class="header" href="#source-code-42">SOURCE CODE</a></h4>
<pre><code class="language-rust  noplayground  EXAMPLE1">fn main() {
  let alfa = 7;

  if check_number(alfa) {
    println!(&quot;got true&quot;);
  } else {
    println!(&quot;got false&quot;);
  }
}

fn check_number(value: i32) -&gt; bool {
  if value == 7 {
    true
  } else {
    false
  }
}</code></pre>
<h3 id="code-runner-41"><a class="header" href="#code-runner-41">CODE RUNNER</a></h3>
<pre><pre class="playground"><code class="language-rust  editable  CODE1"></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="program-3-name-tktktkt"><a class="header" href="#program-3-name-tktktkt">Program 3 NAME TKTKTKT</a></h1>
<p>TODO: Make a version of this with a Vec that returns
both the bool and the i32.</p>
<h3 id="source-code-43"><a class="header" href="#source-code-43">SOURCE CODE</a></h3>
<pre><code class="language-rust  noplayground  EXAMPLE1">fn main() {
  let start = 1;
  let end = 100;
  let splitter = 8;

  for counter in start..=end {
    if should_process(counter, splitter) {
      let how_many_left = count_how_many_left(counter, end);
      println!(&quot;at {counter} with {how_many_left} remaining&quot;);
    }
  }
}

fn should_process(value1: i32, value2: i32) -&gt; bool {
  if value1 % value2 == 0 {
    true
  } else {
    false
  }
}

fn count_how_many_left(value1: i32, value2: i32) -&gt; i32 {
  value2 - value1
}


</code></pre>
<h3 id="code-runner-42"><a class="header" href="#code-runner-42">CODE RUNNER</a></h3>
<pre><pre class="playground"><code class="language-rust  editable  CODE1"></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scopes"><a class="header" href="#scopes">Scopes</a></h1>
<p>TKTKTK Come up with better descriptions
and diagrams for scope.</p>
<p>Rust uses scopes to define what variables
are availalbe in different parts of applicaitons.</p>
<p>One way to think about scopes is like one big
box a collection of smaller boxes inside it.
Each smaller box can have more boxes inside of
them and so on and so forth. A value stored in
a box is avaialble to that box and any box
surround it on the path up to the top box. But,
boxes on the sides can't access it.</p>
<pre><code class="language-txt">&gt; global            1
&gt; global:main       2   fn main() {
&gt; global:main       3     println!(&quot;in main&quot;);
&gt; global:main       4   }
&gt; global            5
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="strings"><a class="header" href="#strings">Strings</a></h1>
<p>We've seen two data types so far: <code>i32</code> and <code>bool</code>.
The first represents a number and the second is
a value that's either <code>true</code> or <code>false</code>. Now let's
start playing with text. To do that we'll use the
<code>String</code> data type.</p>
<p>We only need to put the value we want to use on
the right side of the <code>=</code> sign to create <code>i32</code>
and <code>bool</code> type values. The <code>String</code> type is
a little more complex. It uses this pattern:</p>
<pre><code class="language-rust noplayground">String::from(&quot;brown&quot;);</code></pre>
<p>Creating a <code>String</code> and using it looks like
this:</p>
<h4 id="source-code-44"><a class="header" href="#source-code-44">SOURCE CODE</a></h4>
<pre><code class="language-rust  noplayground  EXAMPLE1">fn main() {
  let color = String::from(&quot;brown&quot;);
  println!(&quot;The quick {color} fox&quot;);
}</code></pre>
<h3 id="code-runner-43"><a class="header" href="#code-runner-43">CODE RUNNER</a></h3>
<pre><pre class="playground"><code class="language-rust  editable  CODE1"></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mutable-strings"><a class="header" href="#mutable-strings">Mutable Strings</a></h1>
<p>Like the other Rust types, <code>String</code> variables are
immutalbe by default. They can be made mutable with
the same <code>mut</code> keyword as the other types as well.</p>
<p>We can do things like add more text to a <code>String</code>
if it's mutable. That can be done with the
method:</p>
<pre><code class="language-rust noplayground">.push_str(&quot;brown fox&quot;)</code></pre>
<p>For example, this prints out</p>
<pre><code class="language-txt">the quick brown fox
</code></pre>
<h4 id="source-code-45"><a class="header" href="#source-code-45">SOURCE CODE</a></h4>
<pre><code class="language-rust  noplayground  EXAMPLE1">fn main() {
  let mut alfa = String::from(&quot;the quick &quot;);
  alfa.push_str(&quot;brown fox&quot;);

  println!(&quot;{}&quot;, alfa);
}</code></pre>
<h3 id="code-runner-44"><a class="header" href="#code-runner-44">CODE RUNNER</a></h3>
<pre><pre class="playground"><code class="language-rust  editable  CODE1"></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="difficulty-increasing"><a class="header" href="#difficulty-increasing">Difficulty Increasing</a></h1>
<p>A quick heads: we're getting into sections
that deal with the more conceptually
complicated parts of Rust. They're
regarded as the harder part of learning the language.</p>
<p>Going through them multiple times before things
click happenes more often than not.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="illustrations-incoming"><a class="header" href="#illustrations-incoming">Illustrations Incoming</a></h1>
<p>My handwriting is chicken scratch.
The upcoming illustrations are drafts. They'll
get replaced once I've got things
more finalized.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="references-old"><a class="header" href="#references-old">References Old</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mutable-references"><a class="header" href="#mutable-references">Mutable References</a></h1>
<p>Mutable references are created using <code>&amp;mut</code> instead
of <code>&amp;</code> to make the reference. The first variable
must be created with <code>mut</code> too. When we make
modifications to the reference the value
change shows up in the <code>alfa</code> variable too.</p>
<p>The steps for this example are:</p>
<ul>
<li>Create a mutable variable named <code>alfa</code>
with a <code>String</code> bound to it</li>
<li>Print <code>alfa</code> to display the value</li>
<li>Create a variable named <code>bravo</code> that
has a mutable reference to <code>alfa</code></li>
<li>Update the value in <code>bravo</code> with
<code>.push_str()</code></li>
<li>Print out <code>bravo</code> to display its
value</li>
<li>Print out <code>alfa</code> again to show
that the value updated there too</li>
</ul>
<p>The output of this code is:</p>
<pre><code class="language-txt">alfa has apple
bravo has applepie
alfa has applepie
</code></pre>
<h3 id="source-code-46"><a class="header" href="#source-code-46">SOURCE CODE</a></h3>
<pre><code class="language-rust  noplayground  EXAMPLE1">fn main() {
  let mut alfa = String::from(&quot;apple&quot;);
  println!(&quot;alfa has {alfa}&quot;);

  let bravo = &amp;mut alfa;
  bravo.push_str(&quot;pie&quot;);

  println!(&quot;bravo has {bravo}&quot;);
  println!(&quot;alfa has {alfa}&quot;);
}</code></pre>
<h3 id="code-runner-45"><a class="header" href="#code-runner-45">CODE RUNNER</a></h3>
<pre><pre class="playground"><code class="language-rust  editable  CODE1"></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a-single-value"><a class="header" href="#a-single-value">A Single Value</a></h1>
<p>TKTKTKT</p>
<h3 id="source-code-47"><a class="header" href="#source-code-47">SOURCE CODE</a></h3>
<pre><pre class="playground"><code class="language-rust  EXAMPLE1">fn main() {
  let mut alfa = String::from(&quot;widget&quot;);
  println!(&quot;alfa is {alfa}&quot;);

  {
    let bravo = &amp;mut alfa;
    println!(&quot;bravo is {bravo}&quot;);
    bravo.push_str(&quot;-thing&quot;);
    println!(&quot;bravo is {bravo}&quot;);
  }

  println!(&quot;alfa is {alfa}&quot;);

}</code></pre></pre>
<h3 id="code-runner-46"><a class="header" href="#code-runner-46">CODE RUNNER</a></h3>
<pre><pre class="playground"><code class="language-rust  editable  CODE1"></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-in-a-function"><a class="header" href="#using-in-a-function">Using In A Function</a></h1>
<p>This is how to pass a reference to a function where
you don't loose ownership</p>
<h3 id="source-code-48"><a class="header" href="#source-code-48">SOURCE CODE</a></h3>
<pre><code class="language-rust  noplayground  EXAMPLE1">fn main() {
  let alfa = String::from(&quot;apple&quot;);
  println!(&quot;alfa is {alfa}&quot;);

  show_value(&amp;alfa);
  println!(&quot;alfa is {alfa}&quot;);
}

fn show_value(param: &amp;String) {
  println!(&quot;show_value got {param}&quot;);
}</code></pre>
<h3 id="code-runner-47"><a class="header" href="#code-runner-47">CODE RUNNER</a></h3>
<pre><pre class="playground"><code class="language-rust  editable  CODE1"></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="changing-in-a-function"><a class="header" href="#changing-in-a-function">Changing In A Function</a></h1>
<h3 id="source-code-49"><a class="header" href="#source-code-49">SOURCE CODE</a></h3>
<pre><pre class="playground"><code class="language-rust  EXAMPLE1">fn main() {
  let mut alfa = String::from(&quot;widget&quot;);
  println!(&quot;alfa is {alfa}&quot;);

  update_value(&amp;mut alfa);
  println!(&quot;alfa is {alfa}&quot;);
}

fn update_value(value: &amp;mut String) {
  value.push_str(&quot;-thing&quot;);
}</code></pre></pre>
<h3 id="code-runner-48"><a class="header" href="#code-runner-48">CODE RUNNER</a></h3>
<pre><pre class="playground"><code class="language-rust  editable  CODE1"></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a-function-error"><a class="header" href="#a-function-error">A Function Error</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ownership-and-moving"><a class="header" href="#ownership-and-moving">Ownership And Moving</a></h1>
<p>Every value in Rust has an &quot;owner&quot;. For example, this
statement assigns a <code>String</code> with the value of <code>apple</code>
to the variable <code>alfa</code>. That makes <code>alfa</code> the owner
of the <code>String</code>.</p>
<pre><code class="language-rust  noplayground">let alfa = String::from(&quot;widget&quot;);</code></pre>
<p>If we create a new variable called <code>bravo</code> by binding
the value of <code>alfa</code> to it, the ownership of the <code>String</code>
passes from <code>alfa</code> to <code>bravo</code>. So this works and will output</p>
<pre><code class="language-txt">alfa contains widget
bravo contains widget
</code></pre>
<h3 id="source-code-50"><a class="header" href="#source-code-50">SOURCE CODE</a></h3>
<pre><code class="language-rust  noplayground  EXAMPLE1">fn main() {
  let alfa = String::from(&quot;widget&quot;);
  println!(&quot;alfa contains {alfa}&quot;);

  let bravo = alfa;
  println!(&quot;bravo contains {bravo}&quot;);
}</code></pre>
<h3 id="code-runner-49"><a class="header" href="#code-runner-49">CODE RUNNER</a></h3>
<pre><pre class="playground"><code class="language-rust  editable  CODE1"></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="moving-strings-error"><a class="header" href="#moving-strings-error">Moving Strings Error</a></h1>
<p>Moving a value means it's no longer in the place
it was before. (That is, it's really a <code>move</code> and
not a <code>copy</code>)</p>
<p>So, when the value of <code>alfa</code> gets moved into
<code>bravo</code> it's no longer available in <code>alfa</code>. Trying
to use it throws an error like this example:</p>
<h3 id="source-code-51"><a class="header" href="#source-code-51">SOURCE CODE</a></h3>
<pre><code class="language-rust  noplayground  EXAMPLE1">fn main() {
  let alfa = String::from(&quot;widget&quot;);
  println!(&quot;alfa contains {alfa}&quot;);

  let bravo = alfa;
  println!(&quot;bravo contains {bravo}&quot;);

  println!(&quot;alfa contains {alfa}&quot;);
}</code></pre>
<h3 id="code-runner-50"><a class="header" href="#code-runner-50">CODE RUNNER</a></h3>
<pre><pre class="playground"><code class="language-rust  editable  CODE1"></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cloning-and-referencing"><a class="header" href="#cloning-and-referencing">Cloning And Referencing</a></h1>
<p>Trying to access a value after we moved it to a new
variable resulted in an error message that contined
this line:</p>
<pre><code class="language-rust noplayground">help: consider cloning the value if the performance cost is acceptable</code></pre>
<p>Cloning is done using the <code>.clone()</code> method. Doing so
changes this:</p>
<pre><code class="language-rust  noplayground">let bravo = alfa;</code></pre>
<p>into this:</p>
<pre><code class="language-rust  noplayground">let bravo = alfa.clone();</code></pre>
<p>When we clone, it makes a new copy of
the <code>String</code> that's bound to <code>alfa</code> and then
binds that new copy to <code>bravo</code>. Since the value
wasn't moved out of <code>alfa</code> we can still use it
like this sample which outputs:</p>
<pre><code class="language-txt">alfa is widget
bravo is widget
alfa is widget
</code></pre>
<h3 id="source-code-52"><a class="header" href="#source-code-52">SOURCE CODE</a></h3>
<pre><code class="language-rust  noplayground  EXAMPLE1">fn main() {
  let alfa = String::from(&quot;widget&quot;);
  println!(&quot;alfa contains {alfa}&quot;);

  let bravo = alfa.clone();
  println!(&quot;bravo contains {bravo}&quot;);

  println!(&quot;alfa contains {alfa}&quot;);
}</code></pre>
<h3 id="code-runner-51"><a class="header" href="#code-runner-51">CODE RUNNER</a></h3>
<pre><pre class="playground"><code class="language-rust  editable  CODE1"></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cloning-for-separate-values"><a class="header" href="#cloning-for-separate-values">Cloning For Separate Values</a></h1>
<p>Cloning the value allows us to modify
<code>alfa</code> and <code>bravo</code> independently (assuming
we've made them mutable with the <code>mut</code>
keyword).</p>
<p>The out we'll get is:</p>
<pre><code class="language-txt">alfa contains widget
bravo contains widget
alfa contains widget-alfa
bravo contains widget-bravo
</code></pre>
<h3 id="source-code-53"><a class="header" href="#source-code-53">SOURCE CODE</a></h3>
<pre><code class="language-rust  noplayground  EXAMPLE1">fn main() {
  let mut alfa = String::from(&quot;widget&quot;);
  let mut bravo = alfa.clone();

  println!(&quot;alfa contains {alfa}&quot;);
  println!(&quot;bravo contains {bravo}&quot;);

  alfa.push_str(&quot;-alfa&quot;);
  bravo.push_str(&quot;-bravo&quot;);

  println!(&quot;alfa contains {alfa}&quot;);
  println!(&quot;bravo contains {bravo}&quot;);
}</code></pre>
<h3 id="code-runner-52"><a class="header" href="#code-runner-52">CODE RUNNER</a></h3>
<pre><pre class="playground"><code class="language-rust  editable  CODE1"></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="binding-values-from-if"><a class="header" href="#binding-values-from-if">Binding Values From if</a></h1>
<p><code>if</code> statements are expressions. That means they return
a value. So, using one on the right side of an <code>=</code> sign
is completely valid.</p>
<p>For example:</p>
<h4 id="source-code-54"><a class="header" href="#source-code-54">SOURCE CODE</a></h4>
<pre><code class="language-rust  noplayground  EXAMPLE1">fn main() {
  let alfa = true;
  let bravo = if alfa { 1 } else { 0 };

  println!(&quot;bravo is {bravo}&quot;)
}</code></pre>
<h3 id="code-runner-53"><a class="header" href="#code-runner-53">CODE RUNNER</a></h3>
<pre><pre class="playground"><code class="language-rust  editable  CODE1"></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="must-be-the-same-type"><a class="header" href="#must-be-the-same-type">Must Be The Same Type</a></h1>
<p>TODO: Put in note earlier about calling the
branches <code>arms</code></p>
<p>Using an <code>if/else</code> expression to determine a
variable to bind directly to a variable requires
both the <code>if</code> arm and the <code>else</code> arm to provide
the same type. So you can have two <code>i32</code> values
like this:</p>
<pre><code class="language-rust  noplayground">let alfa = true;
let bravo = if alfa { 1 } else { 0 };</code></pre>
<p>or two <code>bool</code> values like this:</p>
<pre><code class="language-rust  noplayground">let alfa = true;
let bravo = if alfa { true } else { false };</code></pre>
<p>but you can't mix them like this which will
give an error:</p>
<h4 id="source-code-55"><a class="header" href="#source-code-55">SOURCE CODE</a></h4>
<pre><code class="language-rust  noplayground  EXAMPLE1">fn main() {
  let alfa = true;
  let bravo = if true { 1 } else { false };

  println!(&quot;bravo is {bravo}&quot;);
}</code></pre>
<h3 id="code-runner-54"><a class="header" href="#code-runner-54">CODE RUNNER</a></h3>
<pre><pre class="playground"><code class="language-rust  editable  CODE1"></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mismatched-type-error"><a class="header" href="#mismatched-type-error">Mismatched Type Error</a></h1>
<p>TKTKTKT - Fill in the details on this error.</p>
<p>Here's the error from the prior page:</p>
<pre><code class="language-rust  noplayground  EXAMPLE1">   Compiling playground v0.0.1 (/playground)
error[E0308]: `if` and `else` have incompatible types
 --&gt; src/main.rs:3:36
  |
3 |   let bravo = if true { 1 } else { false };
  |                         -          ^^^^^ expected integer, found `bool`
  |                         |
  |                         expected because of this

For more information about this error, try `rustc --explain E0308`.
error: could not compile `playground` due to previous error</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sandbox"><a class="header" href="#sandbox">Sandbox</a></h1>
<h4 id="source-code-56"><a class="header" href="#source-code-56">SOURCE CODE</a></h4>
<pre><pre class="playground"><code class="language-rust">fn main() {
  let alfa = String::from(&quot;quick&quot;);
  let bravo = alfa;

  println!(&quot;{alfa}&quot;);
}</code></pre></pre>
<pre><pre class="playground"><code class="language-rust">fn main() {
  let alfa = String::from(&quot;quick&quot;);
  widget(alfa);
  println!(&quot;{alfa}&quot;);
}

fn widget(value: String) {
  println!(&quot;{value}&quot;);
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="while-loops"><a class="header" href="#while-loops">While Loops</a></h1>
<p>Rust provides <code>while</code> loops in addition
to <code>for</code> loops. Mutable variables work
well with them by acting as counters.</p>
<p>In this case we'll set a mutable
variable named <code>counter</code> for a while
loop that checks to see if it's less
than or equal to <code>5</code>.</p>
<p>Everytime through <code>1</code>
add <code>1</code> to the counter with <code>+= 1</code>
which takes the current value and
adds one to it.</p>
<h4 id="source-code-57"><a class="header" href="#source-code-57">SOURCE CODE</a></h4>
<pre><code class="language-rust  noplayground  EXAMPLE1">fn main() {

  let mut counter = 1;

  while counter &lt;= 5 {
    println!(&quot;counter is {}&quot;, counter);
    counter = counter + 1;
  }

}</code></pre>
<h3 id="code-runner-55"><a class="header" href="#code-runner-55">CODE RUNNER</a></h3>
<pre><pre class="playground"><code class="language-rust  editable  CODE1"></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="variables-in-println"><a class="header" href="#variables-in-println">Variables In println!</a></h1>
<p>The code from the prior page includes this line:</p>
<pre><code class="language-rust  noplayground">println!(&quot;alfa is {alfa}&quot;);</code></pre>
<p>which produced this output:</p>
<pre><code class="language-rust  noplayground">alfa is 7</code></pre>
<p>The characters first piece of text quoted inside
<code>println!()</code> is called a &quot;format string&quot;. Format
strings can output basic text like we saw with the
original <code>println!(&quot;Hello, World&quot;)</code> example. They can
also output the value of variables like we're
doing with <code>alfa</code> above.</p>
<p>The process works by adding <code>{}</code> curly brackets
with the name of the variable inside it. In our
case this is:</p>
<pre><code class="language-rust  noplayground">{alfa}</code></pre>
<p>Here's another example where we set the variable
<code>bravo</code> to 12 then print it out.</p>
<pre><code class="language-rust noplayground EXAMPLE1">fn main() {
  let bravo = 12;
  println!(&quot;bravo is {bravo}&quot;);
}</code></pre>
<pre><pre class="playground"><code class="language-rust editable CODE1"></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-string-type"><a class="header" href="#the-string-type">The String Type</a></h1>
<p>The <code>i32</code> type allows us to drop in a
number on the first side of the <code>=</code>
sign with no extra fanfare.</p>
<pre><code class="language-rust noplayground">let alfa = ;</code></pre>
<p>The <code>String</code> type requires more work.
Creating a <code>String</code> variable looks like
this:</p>
<pre><code class="language-rust noplayground">let alfa = String::from(&quot;Hello&quot;);</code></pre>
<p>String are defined like this:</p>
<pre><code class="language-rust noplayground">let alfa = String::from(&quot;Hello&quot;);</code></pre>
<p>With <code>i32</code> we could simply drop in the number on
the right side of the <code>=</code>, like:</p>
<pre><code class="language-rust noplayground">let alfa = 7;</code></pre>
<p>the much longer <code>String::from(&quot;Hello&quot;)</code>. The first
word <code>String</code> defines the type. Then, <code>from()</code> is
where we pass in the piece of text we want to
String to be made of.</p>
<h4 id="source-code-58"><a class="header" href="#source-code-58">SOURCE CODE</a></h4>
<pre><code class="language-rust  noplayground  EXAMPLE1">fn main() {

  let alfa = String::from(&quot;Hello&quot;);

  println!(&quot;alfa is {}&quot;, alfa);

}</code></pre>
<h3 id="code-runner-56"><a class="header" href="#code-runner-56">CODE RUNNER</a></h3>
<pre><pre class="playground"><code class="language-rust  editable  CODE1"></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vec"><a class="header" href="#vec">Vec</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="else-if-expressions"><a class="header" href="#else-if-expressions">Else If Expressions</a></h1>
<p>There's a third option we can add beside
<code>if</code> and <code>else</code>. It's called <code>else if</code>. Using
<code>else if</code> creates a new <code>if</code> statement that
only runs if the thing before it was false.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="assignment-operators"><a class="header" href="#assignment-operators">Assignment Operators</a></h1>
<p>That while example added a new type of
expression we haven't seen yet:</p>
<pre><code class="language-rust noplayground">counter += 1;</code></pre>
<p>The <code>+=</code> is an &quot;assignment operator&quot;. They're
like the comparison operators we saw earlier (like
<code>&lt;</code>, <code>&gt;=</code> and <code>==</code>). But, instead of telling
us if the expression they are in is true, assignments
operators do math on the values on either side.</p>
<p>For example, the <code>+=</code> adds whatever is on the
right side to the value on the left. So, this
will give us an output of</p>
<pre><code class="language-txt">1
2
3
</code></pre>
<h4 id="source-code-59"><a class="header" href="#source-code-59">SOURCE CODE</a></h4>
<pre><code class="language-rust  noplayground  EXAMPLE1">fn main() {
  let mut alfa = 1;
  println!(&quot;{}&quot;, alfa);

  alfa += 1;
  println!(&quot;{}&quot;, alfa);

  alfa += 1;
  println!(&quot;{}&quot;, alfa);
}</code></pre>
<h3 id="code-runner-57"><a class="header" href="#code-runner-57">CODE RUNNER</a></h3>
<pre><pre class="playground"><code class="language-rust  editable  CODE1"></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="assignment-operator-examples"><a class="header" href="#assignment-operator-examples">Assignment Operator Examples</a></h1>
<p>The different assignment operators are:</p>
<div class="table-wrapper"><table><thead><tr><th>Operator</th><th>Description</th></tr></thead><tbody>
<tr><td>+=</td><td>Addition</td></tr>
<tr><td>-=</td><td>Subtraction</td></tr>
<tr><td>*=</td><td>Multiply</td></tr>
<tr><td>/=</td><td>Division</td></tr>
<tr><td>%=</td><td>Remainder</td></tr>
</tbody></table>
</div>
<p>Addition, subtraction, and multiplication
behave like everyday math. Here we'll
make an initial set of varilbes and
set them to <code>3</code>. Then we'll add, subtract,
and multiple them with <code>4</code> using the assignment
operators. That will give us:</p>
<pre><code class="language-rust  noplayground">7
-1
12</code></pre>
<h4 id="source-code-60"><a class="header" href="#source-code-60">SOURCE CODE</a></h4>
<pre><code class="language-rust  noplayground  EXAMPLE1">fn main() {

  let mut alfa = 3;
  let mut bravo = 3;
  let mut charlie = 3;

  alfa += 4;
  println!(&quot;{}&quot;, alfa);

  bravo -= 4;
  println!(&quot;{}&quot;, bravo);

  charlie *= 4;
  println!(&quot;{}&quot;, charlie);


}</code></pre>
<h3 id="code-runner-58"><a class="header" href="#code-runner-58">CODE RUNNER</a></h3>
<pre><pre class="playground"><code class="language-rust  editable  CODE1"></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="division"><a class="header" href="#division">Division</a></h1>
<p>The <code>/=</code> operator for division works a little
differently than everyday math. Dividing <code>i32</code>
numbers that go into each other evently works
as expected. For example, <code>6</code> divided by <code>2</code>
will result in <code>3</code>.</p>
<p>However, dividing numbers that don't go into
each other evenly results in just the full
number of times it can (TODO: Look up the
math terms for that.)</p>
<p>Using <code>2</code> and <code>5</code> doesn't give us <code>2.5</code>, it
gives us just the part on the left side of
the decimal (i.e. <code>2</code>)</p>
<h4 id="source-code-61"><a class="header" href="#source-code-61">SOURCE CODE</a></h4>
<pre><code class="language-rust  noplayground  EXAMPLE1">fn main() {
  let mut alfa = 5;
  alfa /= 2;

  println!(&quot;alfa is {}&quot;, alfa);

}</code></pre>
<h3 id="code-runner-59"><a class="header" href="#code-runner-59">CODE RUNNER</a></h3>
<pre><pre class="playground"><code class="language-rust  editable  CODE1"></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="remainder"><a class="header" href="#remainder">Remainder</a></h1>
<p>We use the <code>%=</code> (remainder) assignment
gives us the remainder from a division
operation. For example, dividing <code>9</code>
by <code>2</code> results in <code>2</code> going into <code>9</code>
four times with a remainder of <code>1</code>. That
<code>1</code> is what the <code>%=</code> will give us.</p>
<h4 id="source-code-62"><a class="header" href="#source-code-62">SOURCE CODE</a></h4>
<pre><code class="language-rust  noplayground  EXAMPLE1">fn main() {

  let mut alfa = 9;
  alfa %= 2;

  println!(&quot;alfa is {}&quot;, alfa);
}</code></pre>
<h3 id="code-runner-60"><a class="header" href="#code-runner-60">CODE RUNNER</a></h3>
<pre><pre class="playground"><code class="language-rust  editable  CODE1"></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="data-types-1"><a class="header" href="#data-types-1">Data Types</a></h1>
<p>Rust's design requires every value have a
&quot;type&quot; assigned to. The &quot;type&quot; of a value is what
you'd used to answer a question about what kind of
thing it is. For example, if you were asking someone
about their dog:</p>
<pre><code class="language-txt">What kind of dog is Charlie?

A golden retriever
</code></pre>
<p>And, in a similar manner when discussing a Rust program:</p>
<pre><code class="language-txt">What type of variable is alfa?

A number with a decimal point
</code></pre>
<p>Except we wouldn't use the term &quot;a number with a
decimal point&quot;. We'd use <code>f32</code>. That's what Rust
uses to set the type of a value to a &quot;floating-point
number&quot; (which is a number that has a decimal point
compared to an &quot;integer&quot; which doesn't).</p>
<p>As we saw in the previous chapter, types are assigned
to variables when they are created. We used <code>i32</code>
in the prior examples for integers. We could have used
<code>f32</code> for floating-point numbers just as easily:</p>
<p>For example:</p>
<h4 id="source-code-63"><a class="header" href="#source-code-63">SOURCE CODE</a></h4>
<pre><code class="language-rust  noplayground  EXAMPLE1">fn main() {

  let alfa: f32 = 3.4;

  println!(&quot;Value {}&quot;, alfa);

}</code></pre>
<h4 id="code-runner-61"><a class="header" href="#code-runner-61">CODE RUNNER</a></h4>
<pre><pre class="playground"><code class="language-rust  editable  CODE1"></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="implicit-and-explicit"><a class="header" href="#implicit-and-explicit">Implicit And Explicit</a></h1>
<p>In all our previous examples we've set the
type of our variable explicitly by adding
a <code>:</code> after the name along with the type
(e.g. <code>i32</code>). Rust has the ability to
guess the type of some variables so
that's not always necessary. When we do
that it's called an &quot;implicit&quot; type
assignment and it looks like this:</p>
<pre><code class="language-rust  noplayground">let alfa = 7;</code></pre>
<p>That turns our formula for defining
a variable into this:</p>
<ol>
<li>The <code>let</code> keyword</li>
<li>The optional <code>mut</code> keyword</li>
<li>A name for the variable (e.g. <code>alfa</code>)</li>
<li>A <code>:</code> separator if we're explicitly setting the data type</li>
<li>An optional data type</li>
<li>The <code>=</code> sign</li>
<li>The value to bind to it (e.g. <code>7</code>)</li>
<li>A <code>;</code> the ends the definition</li>
</ol>
<p>In this example, both <code>alfa</code> and <code>bravo</code>
have an <code>i32</code> type. Alfa is defined
explicitly. Bravo is defined implicitly.</p>
<pre><code class="language-rust  noplayground  EXAMPLE1">fn main() {

  let alfa: i32 = 7;

  let bravo = 9;

  println!(&quot;Alfa {} - Bravo {}&quot;, alfa, bravo)

}</code></pre>
<pre><pre class="playground"><code class="language-rust  editable  CODE1"></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-explicit-types"><a class="header" href="#using-explicit-types">Using Explicit Types</a></h1>
<p>Setting data types implicitly like this:</p>
<pre><code class="language-rust noplayground">let alfa = 7;</code></pre>
<p>or explicitly like this:</p>
<pre><code class="language-rust noplayground">let alfa: i32 = 7;</code></pre>
<p>are both frequency occurrences in Rust
programs. While the implicit version is
shorter to type and easier to read we'll
be using the explicit approach for a
few reasons:</p>
<ol>
<li>To get used to the idea that every
value has a type</li>
<li>To use a consistent format in our
examples</li>
<li>Because you can always use explicit
compared to implicit types which only
work sometimes.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-number-types"><a class="header" href="#the-number-types">The Number Types</a></h1>
<p>We've seen both <code>f32</code> for floating point numbers
that have a decimal points and <code>i32</code> for integers
that don't. There's a third type of number
called <code>u32</code> which is for &quot;unsigned integer&quot;.</p>
<p>A regular <code>i32</code> integer can be both positive
and negative where the negative numbers have
a &quot;<code>-</code>&quot; sign in front of them. When we say
a <code>u32</code> is unsigned, it means it can't have
a &quot;<code>-</code>&quot; sign. That it turn means it can't
be negative.</p>
<p>This brings us to the <code>32</code> that follows the
<code>f</code>, <code>i</code>, and <code>u</code> in the types. It
determines how big a number can be used for
the variable.</p>
<p>Here's the values for floating point numbers</p>
<div class="table-wrapper"><table><thead><tr><th>type</th><th>lowest number</th><th>highest number</th></tr></thead><tbody>
<tr><td>f8</td><td>TKTKTKT</td><td>TKTKTKT</td></tr>
<tr><td>f16</td><td>TKTKTKT</td><td>TKTKTKT</td></tr>
<tr><td>f32</td><td>TKTKTKT</td><td>TKTKTKT</td></tr>
<tr><td>f64</td><td>TKTKTKT</td><td>TKTKTKT</td></tr>
<tr><td>f128</td><td>TKTKTKT</td><td>TKTKTKT</td></tr>
</tbody></table>
</div>
<p>Here's the values for integers</p>
<div class="table-wrapper"><table><thead><tr><th>type</th><th>lowest number</th><th>highest number</th></tr></thead><tbody>
<tr><td>i8</td><td>TKTKTKT</td><td>TKTKTKT</td></tr>
<tr><td>i16</td><td>TKTKTKT</td><td>TKTKTKT</td></tr>
<tr><td>i32</td><td>TKTKTKT</td><td>TKTKTKT</td></tr>
<tr><td>i64</td><td>TKTKTKT</td><td>TKTKTKT</td></tr>
<tr><td>i128</td><td>TKTKTKT</td><td>TKTKTKT</td></tr>
</tbody></table>
</div>
<p>And, here's the values for unsigned integers</p>
<div class="table-wrapper"><table><thead><tr><th>type</th><th>lowest number</th><th>highest number</th></tr></thead><tbody>
<tr><td>u8</td><td>TKTKTKT</td><td>TKTKTKT</td></tr>
<tr><td>u16</td><td>TKTKTKT</td><td>TKTKTKT</td></tr>
<tr><td>u32</td><td>TKTKTKT</td><td>TKTKTKT</td></tr>
<tr><td>u64</td><td>TKTKTKT</td><td>TKTKTKT</td></tr>
<tr><td>u128</td><td>TKTKTKT</td><td>TKTKTKT</td></tr>
</tbody></table>
</div>
<hr />
<h3 id="todo"><a class="header" href="#todo">TODO</a></h3>
<ul>
<li>
<p>Fill in the high/low values</p>
</li>
<li>
<p>Add notes about <code>arch</code></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="booleans-1"><a class="header" href="#booleans-1">Booleans</a></h1>
<p>Rust has another fundamental data type
called &quot;Boolean&quot;.</p>
<p>A boolean is either true or false. It
can't be anything else. They use the
<code>bool</code> keyword and are assigned like
this:</p>
<pre><code class="language-rust noplayground">let bravo: bool = false;</code></pre>
<p>Used in a full program it looks like this:</p>
<h4 id="source-code-64"><a class="header" href="#source-code-64">SOURCE CODE</a></h4>
<pre><code class="language-rust noplayground  EXAMPLE1">fn main() {

  let alfa: bool = true;

  println!(&quot;Value {}&quot;, alfa);

}</code></pre>
<h4 id="code-runner-62"><a class="header" href="#code-runner-62">CODE RUNNER</a></h4>
<pre><pre class="playground"><code class="language-rust editable  CODE1"></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compound-data-types"><a class="header" href="#compound-data-types">Compound Data Types</a></h1>
<p>The floating-point, integer, and boolean data
types we've covered each hold a single value.
Collectively, they're called &quot;scalar&quot; types (TODO:
find where the term scalar comes from)</p>
<p>Rust has another category of types called &quot;compound&quot;
types. They hold multiple values instead of being
constrained to a single one.</p>
<p>Compound data types come in two flavors: Tuples and Arrays.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tuples"><a class="header" href="#tuples">Tuples</a></h1>
<p>Tuples are containers that hold other values
of different types.</p>
<p>Creating a tuple variable looks different than
making one for a scalar data type.
Instead of using a specific keyword after the variable's
name (like <code>i32</code> in <code>let alfa: i32 = 58</code>), tuple definitions
use a pair of parenthesis with the types it's
going to contain between them.</p>
<p>To the right side of the equal sign the values
to assign are placed in a corresponding set of
parenthesis.</p>
<p>For example, defining a tuple with three
integers looks like this:</p>
<pre><code class="language-rust  noplayground">let alfa: (i32, i32, i32) = (5, 7, 9);</code></pre>
<p>Making one with a float and a boolean looks
like this:</p>
<pre><code class="language-rust  noplayground">let bravo: (f32, bool) = (37.9, false);</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tuple-indexes"><a class="header" href="#tuple-indexes">Tuple Indexes</a></h1>
<p>Getting values out of a tuple is done using
the variable's name followed by a dot and
the &quot;index&quot; number for the position we're
after.</p>
<p>For example:</p>
<pre><code class="language-rust  noplayground">alfa.2</code></pre>
<p>The index position represents a counter
that starts at the beginning of the tuple
and goes up one for each position. But, the
first number is zero instead of one. So,
the first position is <code>0</code>, the second position
is <code>1</code>, etc...</p>
<p>Here's an example creating a tuple that holds an
<code>i32</code>, a <code>f32</code>, and a <code>bool</code> and then prints
them out.</p>
<h4 id="source-code-65"><a class="header" href="#source-code-65">SOURCE CODE</a></h4>
<pre><code class="language-rust noplayground EXAMPLE1">fn main() {

  let alfa: (i32, f32, bool) = (99, 234.5, false);

  println!(&quot;1st {}&quot;, alfa.0);
  println!(&quot;2nd {}&quot;, alfa.1);
  println!(&quot;3rd {}&quot;, alfa.2);

}</code></pre>
<h4 id="code-runner-63"><a class="header" href="#code-runner-63">CODE RUNNER</a></h4>
<pre><pre class="playground"><code class="language-rust editable CODE1"></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="indexes-and-offsets"><a class="header" href="#indexes-and-offsets">Indexes And Offsets</a></h1>
<p>The name for the way these index numbers
work is &quot;zero based index&quot;. The way I've
learned to think about them is as a
position offset.</p>
<p>We always start with the first item position.
If we want the value of that item it doesn't
require moving. That translates, to zero offset
from which means index of <code>0</code>.</p>
<p>The second number is one away from the start.
So, we access it with an index of <code>1</code>.</p>
<p>To get to the third number requires moving
two steps from the start. That gives us
and index of <code>2</code></p>
<p>Regardless of the way you think about it,
working with zero based indexes can take
some time to get used to. Even folks
who've been programming for years screw it
up sometimes.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions-1"><a class="header" href="#functions-1">Functions</a></h1>
<p>Every program we've run so far has consisted of
the single <code>main</code> function. It's definition
starts with <code>fn</code> followed by the name of the
function with some parenthesis (i.e. <code>main()</code>),
then the opening and closing <code>{}</code> curly braces
that wrap the code that gets executed when
the function is called.</p>
<p>We can add more functions to our programs as
well using the same approach. For example,
here's the definition of a function named
&quot;alfa&quot; that prints out &quot;I am alfa&quot;:</p>
<pre><code class="language-rust noplayground">fn alfa() {
  println!(&quot;I am alfa&quot;);
}</code></pre>
<p>The function is used by &quot;calling it&quot;. The
syntax for that is the name of the function
followed by parenthesis:</p>
<pre><code class="language-rust noplayground">alfa();</code></pre>
<p>Here's a full program where we
print <code>I am main</code> inside the main function
then call the <code>alfa</code> function which
then prints <code>I am alfa</code></p>
<h4 id="source-code-66"><a class="header" href="#source-code-66">SOURCE CODE</a></h4>
<pre><code class="language-rust noplayground EXAMPLE1">fn main() {
  println!(&quot;I am main&quot;);
  alfa()
}

fn alfa() {
  println!(&quot;I am alfa&quot;);
}</code></pre>
<h4 id="code-runner-64"><a class="header" href="#code-runner-64">CODE RUNNER</a></h4>
<pre><pre class="playground"><code class="language-rust  editable  CODE1"></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="function-parameters"><a class="header" href="#function-parameters">Function Parameters</a></h1>
<p>We can also send data to functions for
them to use. In order to do this we have
to let the functions know a few things.
To start with, those are:</p>
<ol>
<li>That data will be coming in</li>
<li>What type of data it will be</li>
<li>A variable name to use to hold the incoming data</li>
</ol>
<p>The way we do that is to assign a variable inside
the parenthesis after the function name. The format
is similar to what we've used to assigning variable
so far but we remove the <code>let</code>, <code>=</code>, and the value.</p>
<p>So instead of this:</p>
<pre><code class="language-rust  noplayground">let alfa: i32 = 3</code></pre>
<p>we'd pull out just this part:</p>
<pre><code class="language-rust  noplayground">alfa: i32</code></pre>
<p>To use that in a function named <code>widget</code> we'd write this:</p>
<pre><code class="language-rust  noplayground">fn widget(alfa: i32) {
  println!(&quot;I am alfa&quot;);
}</code></pre>
<hr />
<p>TODO: Combine this with the next page since it doesn't
really make sense to show the incoming parameter
but not use it.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-function-parameters"><a class="header" href="#using-function-parameters">Using Function Parameters</a></h1>
<p>Our widget function defined a parameter
called <code>alfa</code> of type <code>i32</code>. In order
to use it, we have to pass it in when
we call the function. This is done
by putting the value we want to use
inside the parenthesis when we call
the function. For example:</p>
<pre><code class="language-rust noplayground">widget(7);</code></pre>
<p>Once we do that we can use the value
vai the <code>alfa</code> variable we set inside
the function definition.</p>
<p>For example:</p>
<pre><code class="language-rust noplayground EXAMPLE1">fn main() {
  println!(&quot;This is main&quot;);
  widget(7);
}


fn widget(alfa: i32) {
  println!(&quot;This is widget with {}&quot;, alfa);
}</code></pre>
<pre><pre class="playground"><code class="language-rust  editable  CODE1"></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="multiple-function-parameters"><a class="header" href="#multiple-function-parameters">Multiple Function Parameters</a></h1>
<p>Defining functions that take more than
one parameter is done by adding more
in the parentheses that are separated
by commas like this:</p>
<pre><code class="language-rust noplayground">widget(alfa: i32, bravo: f32)</code></pre>
<p>Here's a full program:</p>
<h4 id="source-code-67"><a class="header" href="#source-code-67">SOURCE CODE</a></h4>
<pre><code class="language-rust noplayground EXAMPLE1">fn main() {
  println!(&quot;This is main&quot;);
  widget(7, 3.4);
}

fn widget(alfa: i32, bravo: f32) {
  println!(&quot;This is widget&quot;);
  println!(&quot;Alfa {} - Bravo {}&quot;, alfa, bravo);
}</code></pre>
<h4 id="code-runner-65"><a class="header" href="#code-runner-65">CODE RUNNER</a></h4>
<pre><pre class="playground"><code class="language-rust editable CODE1"></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-multiple-parameters"><a class="header" href="#using-multiple-parameters">Using Multiple Parameters</a></h1>
<p>Parameters don't have to be kept independent
when we pass them into a function. For example,
if we use to <code>i32</code> integers we can add them
together in a new variable and print it. In
this case we'll use a function named
<code>do_addition</code>. The output of the program
will be:</p>
<pre><code class="language-txt">This is main
do_addition made 8
</code></pre>
<h4 id="source-code-68"><a class="header" href="#source-code-68">SOURCE CODE</a></h4>
<pre><code class="language-rust noplayground  EXAMPLE1">fn main() {
  println!(&quot;This is main&quot;);
  do_addition(3, 5);
}

fn do_addition(alfa: i32, bravo: i32) {
  let sum = alfa + bravo;
  println!(&quot;do_addition made {}&quot;, sum);
}</code></pre>
<h4 id="code-runner-66"><a class="header" href="#code-runner-66">CODE RUNNER</a></h4>
<pre><pre class="playground"><code class="language-rust editable CODE1"></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="function-return-values-1"><a class="header" href="#function-return-values-1">Function Return Values</a></h1>
<p>The <code>widget</code> function in the previous
examples received a value from <code>main</code>
but didn't pass anything back. Setting
up to do that is a matter of defining
the type of data the function will
return. This is done by adding
a <code>-&gt;</code> and data type after the function
name and associated <code>()</code> for the
incoming parameters.</p>
<p>The format without any incoming
parameters that returns an <code>i32</code>
integer looks like this:</p>
<pre><code class="language-rust noplayground">widget() -&gt; i32</code></pre>
<p>Here's what everything looks like in a
program. It will output:</p>
<pre><code class="language-txt">widget is 10
</code></pre>
<h4 id="source-code-69"><a class="header" href="#source-code-69">SOURCE CODE</a></h4>
<pre><code class="language-rust noplayground EXAMPLE1">fn main() {
  println!(&quot;widget is {}&quot;, widget());
}

fn widget() -&gt; i32 {
  5 + 5
}</code></pre>
<h4 id="code-runner-67"><a class="header" href="#code-runner-67">CODE RUNNER</a></h4>
<pre><pre class="playground"><code class="language-rust editable CODE1"></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="binding-return-values"><a class="header" href="#binding-return-values">Binding Return Values</a></h1>
<p>The values return from functions can
be bound to variables. For example,
if we create a variable named <code>alfa</code>
of type <code>i32</code> we can set it to
the return value of a <code>widget</code>
function that has the same time.</p>
<p>Here's a program which outputs:</p>
<pre><code class="language-txt">alfa is 9
</code></pre>
<h4 id="source-code-70"><a class="header" href="#source-code-70">SOURCE CODE</a></h4>
<pre><code class="language-rust noplayground EXAMPLE1">fn main() {
  let alfa = widget();
  println!(&quot;alfa is {}&quot;, alfa);
}

fn widget() -&gt; i32 {
  3 + 6
}</code></pre>
<h4 id="code-runner-68"><a class="header" href="#code-runner-68">CODE RUNNER</a></h4>
<pre><pre class="playground"><code class="language-rust  editable  CODE1"></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="return-expressions"><a class="header" href="#return-expressions">Return Expressions</a></h1>
<p>The <code>widget</code> function in the last example
looked like this:</p>
<pre><code class="language-rust noplayground">fn widget() -&gt; i32 {
  3 + 6
}</code></pre>
<p>I bring that up to point out that there isn't
a <code>;</code> after the <code>3 + 6</code>. This is different
from all the other lines we've seen
in functions so far.</p>
<p>There are three reasons for this:</p>
<ol>
<li>Rust functions return the last
expression at the end of their code block</li>
<li>The <code>;</code> ends expressions.</li>
<li>Rust has a default return type that we'll
discuss on the next page.</li>
</ol>
<p>What all that means is if we did this:</p>
<pre><code class="language-rust noplayground">3 + 6;</code></pre>
<p>instead of:</p>
<pre><code class="language-rust noplayground">3 + 6</code></pre>
<p>we'd be end the expression that did
the addition. That expression is
what provides the <code>i32</code> value that the
function is setup to return based off
its definition. So, we'd end up with an
error.</p>
<p>Run the code again with the <code>;</code> in place
to see what the error looks like and we'll
talk about it on the next page.</p>
<h4 id="source-code-71"><a class="header" href="#source-code-71">SOURCE CODE</a></h4>
<pre><code class="language-rust noplayground EXAMPLE1">fn main() {
  let alfa = widget();
  println!(&quot;alfa is {}&quot;, alfa);
}

fn widget() -&gt; i32 {
  3 + 6;
}</code></pre>
<h4 id="code-runner-69"><a class="header" href="#code-runner-69">CODE RUNNER</a></h4>
<pre><pre class="playground"><code class="language-rust  editable  CODE1"></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="return-expression-errors"><a class="header" href="#return-expression-errors">Return Expression Errors</a></h1>
<p>(TODO: Split this into multiple pages)</p>
<p>Here's the error message from the prior page
where we intentionally put a semi-colon at
the end of an expression that caused an error.</p>
<pre><code class="language-rust noplayground">   Compiling playground v0.0.1 (/playground)
error[E0308]: mismatched types
 --&gt; src/main.rs:6:16
  |
6 | fn widget() -&gt; i32 {
  |    ------      ^^^ expected `i32`, found `()`
  |    |
  |    implicitly returns `()` as its body has no tail or `return` expression
7 |   3 + 6;
  |        - help: remove this semicolon to return this value

For more information about this error, try `rustc --explain E0308`.
error: could not compile `playground` due to previous error</code></pre>
<p>The Rust error message are great but they can
be pretty overwhelming at first. Let's to through
it piece by piece to get a better idea of what
happened.</p>
<h3 id=""><a class="header" href="#">*****</a></h3>
<pre><code class="language-rust  noplayground">Compiling playground v0.0.1 (/playground)</code></pre>
<p>This is a note from the rust compiler letting us
know what it's working on. The site uses Rust Playground
to compile and run code. This is the name it uses
on its side.</p>
<h3 id="-1"><a class="header" href="#-1">*****</a></h3>
<pre><code class="language-rust  noplayground">error[E0308]: mismatched types
 --&gt; src/main.rs:6:16</code></pre>
<p>TKTKTK</p>
<h3 id="-2"><a class="header" href="#-2">*****</a></h3>
<pre><code class="language-rust  noplayground">6 | fn widget() -&gt; i32 {
  |    ------      ^^^ expected `i32`, found `()`</code></pre>
<p>TKTKTK</p>
<h3 id="-3"><a class="header" href="#-3">*****</a></h3>
<pre><code class="language-rust  noplayground">6 | fn widget() -&gt; i32 {
  |    ------      ^^^ expected `i32`, found `()`
  |    |
  |    implicitly returns `()` as its body has no tail or `return` expression</code></pre>
<p>We've added two lines to the two in the prior description.</p>
<p>TKTKTK</p>
<h3 id="-4"><a class="header" href="#-4">*****</a></h3>
<pre><code class="language-rust  noplayground">7 |   3 + 6;
  |        - help: remove this semicolon to return this value</code></pre>
<p>TKTKTK</p>
<h3 id="-5"><a class="header" href="#-5">*****</a></h3>
<pre><code class="language-rust  noplayground">For more information about this error, try `rustc --explain E0308`.
error: could not compile `playground` due to previous error</code></pre>
<p>TKTKTK</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions-review"><a class="header" href="#functions-review">Functions Review</a></h1>
<p>This chapter covered:</p>
<ul>
<li>Functions with no parameters</li>
<li>Functions with parameters</li>
<li>Using parameters</li>
<li>Functions with return values</li>
<li>Binding return values</li>
</ul>
<p>Here's a review the combines everything. It
outputs</p>
<pre><code class="language-txt">sum is 12
</code></pre>
<h4 id="source-code-72"><a class="header" href="#source-code-72">SOURCE CODE</a></h4>
<pre><code class="language-rust noplayground EXAMPLE1">fn main() {
  let sum = do_addition(5, 7);
  println!(&quot;sum is {}&quot;, sum);
}

fn do_addition(alfa: i32, bravo: i32) -&gt; i32 {
  let response = alfa + bravo;
  response
}</code></pre>
<h4 id="code-runner-70"><a class="header" href="#code-runner-70">CODE RUNNER</a></h4>
<pre><pre class="playground"><code class="language-rust  editable  CODE1"></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="if-expressions-1"><a class="header" href="#if-expressions-1">if Expressions</a></h1>
<p><code>if</code> expressions are used to determine
if a section of code should be run or not.
They are created with:</p>
<ol>
<li>The <code>if</code> keyword</li>
<li>A condition to check</li>
<li>A block of code to run if the condition is true.</li>
</ol>
<p>The condition in the example below checks to see if the
number <code>3</code> is less than the number <code>4</code> using the <code>&lt;</code> math
symbol like this:</p>
<pre><code class="language-rust noplayground">3 &lt; 4</code></pre>
<p>Since the <code>3</code> <strong>is</strong> less than <code>4</code> the condition is
true so we'll see the output <code>the condition is true</code>.</p>
<h3 id="source-code-73"><a class="header" href="#source-code-73">SOURCE CODE</a></h3>
<pre><code class="language-rust  noplayground  EXAMPLE1">fn main() {
  if 3 &lt; 4 {
    println!(&quot;the condition is true&quot;);
  }
}</code></pre>
<h3 id="code-runner-71"><a class="header" href="#code-runner-71">CODE RUNNER</a></h3>
<pre><pre class="playground"><code class="language-rust  editable  CODE1"></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="false-conditions-in-if-expressions"><a class="header" href="#false-conditions-in-if-expressions">false Conditions In if Expressions</a></h1>
<p>The condition that was checked in the prior
example (i.e. <code>3 &lt; 4</code>) was true. Because
of that, Rust ran the code inside the
code block and printed our &quot;3 is less than 4&quot;
output. The block of code won't run if we end
up with an <code>if</code> condition that's false instead of
true.</p>
<p>In this example we'll do another check. This time
will do one that's false. We'll also add a couple
<code>println!()</code> expressions to help see what's
going on. Specifically, we'll see the output
from the two <code>println!()</code> expressions that are
outside the <code>if</code>. But, we won't see the one
inside the <code>if</code>. It'll looks like this:</p>
<pre><code class="language-txt">alfa
charlie
</code></pre>
<h4 id="source-code-74"><a class="header" href="#source-code-74">SOURCE CODE</a></h4>
<pre><code class="language-rust  noplayground  EXAMPLE1">fn main() {

  println!(&quot;alfa&quot;);

  if 3 &gt; 4 {
    println!(&quot;bravo&quot;);
  }

  println!(&quot;charlie&quot;);

}</code></pre>
<h4 id="code-runner-72"><a class="header" href="#code-runner-72">CODE RUNNER</a></h4>
<pre><pre class="playground"><code class="language-rust  editable  CODE1"></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="else-expressions"><a class="header" href="#else-expressions">else Expressions</a></h1>
<p>The value of a condition in an <code>if</code> expression
must be either <code>true</code> or <code>false</code>. If the
condition's value is <code>true</code> the code block
gets executed. If the condition is <code>false</code>
it doesn't.</p>
<p>Executing an alternate code block when an <code>if</code>
condition is <code>false</code> is done with an <code>else</code>
expression.</p>
<p>This example sets up an <code>if</code> statements that
runs if 5 is less than 4. We'll follow it with
an <code>else</code> expression that will get run since
evaluating <code>5 &lt; 4</code> is <code>false</code></p>
<p>The output will be:</p>
<pre><code class="language-txt">5 is not less than 4
</code></pre>
<h4 id="source-code-75"><a class="header" href="#source-code-75">SOURCE CODE</a></h4>
<pre><code class="language-rust  noplayground  EXAMPLE1">fn main() {

  if 5 &lt; 4 {
    println!(&quot;5 is less than 4&quot;);
  } else {
    println!(&quot;5 is not less than 4&quot;);
  }

}</code></pre>
<h4 id="code-runner-73"><a class="header" href="#code-runner-73">CODE RUNNER</a></h4>
<pre><pre class="playground"><code class="language-rust  editable  CODE1"></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="else-if-expressions-1"><a class="header" href="#else-if-expressions-1">else if Expressions</a></h1>
<p>TODO: Make an earlier example showing using
a variable for the condition so you don't
have to explain it here.</p>
<hr />
<p>Rust also provides an <code>else if</code> expression. It goes
in between <code>if</code> and <code>else</code> expressions and gets
a condition to check like the initial <code>if</code> statement
does.</p>
<h4 id="source-code-76"><a class="header" href="#source-code-76">SOURCE CODE</a></h4>
<pre><code class="language-rust  noplayground  EXAMPLE1">fn main() {

  let value = 5;

  if value &lt; 3 {
    println!(&quot;alfa&quot;);
  } else if value &lt; 7 {
    println!(&quot;bravo&quot;);
  } else {
    println!(&quot;charlie&quot;);
  }

}</code></pre>
<h4 id="code-runner-74"><a class="header" href="#code-runner-74">CODE RUNNER</a></h4>
<pre><pre class="playground"><code class="language-rust  editable  CODE1"></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="multiple-if-else-expressions"><a class="header" href="#multiple-if-else-expressions">Multiple if else Expressions</a></h1>
<h4 id="source-code-77"><a class="header" href="#source-code-77">SOURCE CODE</a></h4>
<pre><code class="language-rust  noplayground  EXAMPLE1">fn main() {

  let value = 7;

  if value &lt;= 5 {
    println!(&quot;alfa&quot;);

  } else if value &lt;= 6 {
    println!(&quot;bravo&quot;);

  } else if value &lt;= 7 {
    println!(&quot;charlie&quot;);

  } else if value &lt;= 8 {
    println!(&quot;delta&quot;);

  } else {
    println!(&quot;echo&quot;);
  }

}</code></pre>
<h3 id="code-runner-75"><a class="header" href="#code-runner-75">CODE RUNNER</a></h3>
<pre><pre class="playground"><code class="language-rust  editable  CODE1"></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="function-example"><a class="header" href="#function-example">Function Example</a></h1>
<h4 id="source-code-78"><a class="header" href="#source-code-78">SOURCE CODE</a></h4>
<pre><code class="language-rust  noplayground  EXAMPLE1">fn main() {

  let value = 5;

  if is_value_seven(value) {
    println!(&quot;yes&quot;);
  } else {
    println!(&quot;no&quot;);
  }

}

fn is_value_seven(check_value: i32) -&gt; bool {
  check_value == 7
}</code></pre>
<h4 id="code-runner-76"><a class="header" href="#code-runner-76">CODE RUNNER</a></h4>
<pre><pre class="playground"><code class="language-rust  editable  CODE1"></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="binding-variables"><a class="header" href="#binding-variables">Binding Variables</a></h1>
<p>NOTE: Since we're using the <code>if</code> with <code>let</code>
it must have a <code>;</code> after the last part
of the expression.</p>
<h4 id="source-code-79"><a class="header" href="#source-code-79">SOURCE CODE</a></h4>
<pre><code class="language-rust  noplayground  EXAMPLE1">fn main() {

  let alfa = true;

  let bravo = if alfa {
    0
  } else {
    1
  };

  println!(&quot;bravo is {}&quot;, bravo);
}</code></pre>
<h3 id="code-runner-77"><a class="header" href="#code-runner-77">CODE RUNNER</a></h3>
<pre><pre class="playground"><code class="language-rust  editable  CODE1"></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="binding-values-must-be-the-same"><a class="header" href="#binding-values-must-be-the-same">Binding Values Must Be The Same</a></h1>
<p>This will break via: https://doc.rust-lang.org/book/ch03-05-control-flow.html
because the values from the two arms of the <code>if</code> aren't the
same type. This will throw an error that we'll look at
on the next page.</p>
<h4 id="source-code-80"><a class="header" href="#source-code-80">SOURCE CODE</a></h4>
<pre><code class="language-rust  noplayground  EXAMPLE1">fn main() {

  let alfa = if 3 &lt;= 4 {
    0
  } else {
    false
  };

  println!(&quot;alfa is {}&quot;, alfa);

}</code></pre>
<h3 id="code-runner-78"><a class="header" href="#code-runner-78">CODE RUNNER</a></h3>
<pre><pre class="playground"><code class="language-rust  editable  CODE1"></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="incompatible-types"><a class="header" href="#incompatible-types">Incompatible Types</a></h1>
<p>TODO: Build out this page with the error
from the prior page.</p>
<h4 id="source-code-81"><a class="header" href="#source-code-81">SOURCE CODE</a></h4>
<pre><code class="language-rust  noplayground  EXAMPLE1">   Compiling playground v0.0.1 (/playground)
error[E0308]: `if` and `else` have incompatible types
 --&gt; src/main.rs:6:5
  |
3 |     let alfa = if 3 &lt;= 4 {
  |  ______________-
4 | |     0
  | |     - expected because of this
5 | |   } else {
6 | |     false
  | |     ^^^^^ expected integer, found `bool`
7 | |   };
  | |___- `if` and `else` have incompatible types

For more information about this error, try `rustc --explain E0308`.
error: could not compile `playground` due to previous error</code></pre>
<h3 id="code-runner-79"><a class="header" href="#code-runner-79">CODE RUNNER</a></h3>
<pre><pre class="playground"><code class="language-rust  editable  CODE1"></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="while-loops-1"><a class="header" href="#while-loops-1">While Loops</a></h1>
<p>The condition check is built in.</p>
<h4 id="source-code-82"><a class="header" href="#source-code-82">SOURCE CODE</a></h4>
<pre><code class="language-rust  noplayground  EXAMPLE1">fn main() {
  let mut alfa = 1;

  while alfa &lt;= 5 {
    println!(&quot;alfa is {}&quot;, alfa);
    alfa += 1;
  }
}</code></pre>
<h3 id="code-runner-80"><a class="header" href="#code-runner-80">CODE RUNNER</a></h3>
<pre><pre class="playground"><code class="language-rust  editable  CODE1"></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="assignments-from-while-loops"><a class="header" href="#assignments-from-while-loops">Assignments From While Loops</a></h1>
<p>TODO: Figure out if you can do this
or not.</p>
<h4 id="source-code-83"><a class="header" href="#source-code-83">SOURCE CODE</a></h4>
<pre><pre class="playground"><code class="language-rust  editable  EXAMPLE1">fn main() {
  let mut alfa = 1;

  let bravo = while alfa &lt;= 5 {
    println!(&quot;alfa is {}&quot;, alfa);
    alfa += 1;
    alfa * 2
  };

  println!(&quot;bravo is {}&quot;, bravo);

}</code></pre></pre>
<h3 id="code-runner-81"><a class="header" href="#code-runner-81">CODE RUNNER</a></h3>
<pre><pre class="playground"><code class="language-rust  editable  CODE1"></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="for-loops-1"><a class="header" href="#for-loops-1">For Loops</a></h1>
<p>TODO: Switch to using a Vec instead of
and array probably since Vecs are
what will have been used elsewhere.</p>
<h4 id="source-code-84"><a class="header" href="#source-code-84">SOURCE CODE</a></h4>
<pre><code class="language-rust  noplayground  EXAMPLE1">fn main() {

  let alfa = [5, 10, 15, 20];

  for item in alfa {
    println!(&quot;item is {}&quot;, item)
  }
}</code></pre>
<h3 id="code-runner-82"><a class="header" href="#code-runner-82">CODE RUNNER</a></h3>
<pre><pre class="playground"><code class="language-rust  editable  CODE1"></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-ranges-in-for-loops"><a class="header" href="#using-ranges-in-for-loops">Using Ranges In For Loops</a></h1>
<h4 id="source-code-85"><a class="header" href="#source-code-85">SOURCE CODE</a></h4>
<pre><pre class="playground"><code class="language-rust  editable  EXAMPLE1">fn main() {

  for alfa in (1..10) {
    println!(&quot;alfa is {}&quot;, alfa)
  }

}
</code></pre></pre>
<h3 id="code-runner-83"><a class="header" href="#code-runner-83">CODE RUNNER</a></h3>
<pre><pre class="playground"><code class="language-rust  editable  CODE1"></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-messages-in-tutorials"><a class="header" href="#error-messages-in-tutorials">Error Messages In Tutorials</a></h1>
<p>Getting hit with a typo error when you're trying to 
learn something else is a waste of time, energy, and 
motivation.</p>
<p>The Status line is there to prevent type errors, 
but we won't ignore error messages. Learning to read 
them is a critical part of learning a programming 
language.</p>
<p>Error messages can come from two categories of mistakes:</p>
<ol>
<li>Doing something wrong </li>
<li>Typing something wrong</li>
</ol>
<p>We'll look at both types, but we'll do it intentionally
using Source Code blocks specificaly designed to 
demonstrate them. </p>
<p>The first thing is to point out that &quot;wrong&quot; in this
context is not bad. It's more like when you walk
up to a door and try to open it by pushing instead
of pullling. You tried to do the wrong thing, but 
there's nothing bad about it. You do it another way
until you find something that works. </p>
<p>We'll look at both types of error messages</p>
<p>Understanding error messages is a critical part of
learning a language. But, they're best studied
explicitly. During a tutorial, error messages from</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="messing-with-the-code"><a class="header" href="#messing-with-the-code">Messing With The Code</a></h1>
<p>The Status line typo warnings won't prevent you from
running code. You can fiddle with the examples
and run them to see what happens even though the
warning will let you know you've drifted away
from the example source code.</p>
<p>I've got a feature on the road map to disable the
typo catcher. That'll make playing with the examples
more friendly since it won't be throwing the warning
at you when you change things.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="preamble"><a class="header" href="#preamble">Preamble</a></h1>
<p>There are a few other things to cover before we get
started with the code.</p>
<h3 id="the-content"><a class="header" href="#the-content">The Content</a></h3>
<ul>
<li>
<p>These are my actual, in-progress notes on learning
Rust. As such, the site is very much a work in progress.
It only goes far as I've made it in my studies.</p>
</li>
<li>
<p>The content is designed for folks who have at least some
programming experience. If you know what variables,
functions, loops, and conditionals are, you'll be fine.</p>
</li>
</ul>
<h3 id="the-examples"><a class="header" href="#the-examples">The Examples</a></h3>
<ul>
<li>
<p>Examples are kept intentionally sort. That often
means doing things that would be silly in a useful
program. For example, defining a variable that's
used only once on the following line. The goal is to
show <em>how</em> to use something not <em>when</em> to use it.</p>
</li>
<li>
<p>Examples use the NATO phonetic alphabet (alfa,
bravo, charlie, etc...). The words have no meaning
beyond being labels or acting as content.</p>
</li>
</ul>
<h3 id="typing-it-in"><a class="header" href="#typing-it-in">Typing It In</a></h3>
<ul>
<li>
<p>The approach of typing in examples may feel weird and
frustrating at first if you've never done it. Give it
5-10 pages to see if you start to find it useful.</p>
</li>
<li>
<p>Of course, you can also read the site like a book without
typing anything in if you learn better that way.</p>
</li>
</ul>
<p>Now, let's get started with a better look at Hello, World.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-string-type-1"><a class="header" href="#the-string-type-1">The String Type</a></h1>
<p>TODO: Figure out if you want to do
string literals before this or not. I'm
thinking not so that we only have to
think about a single string type for
the early part of the book. Push
the literals to later.</p>
<p>Example showing how to add more text
to a mutable String</p>
<h4 id="source-code-86"><a class="header" href="#source-code-86">SOURCE CODE</a></h4>
<pre><code class="language-rust  noplayground  EXAMPLE1">fn main() {

  let mut alfa = String::from(&quot;Hello&quot;);
  println!(&quot;alfa is {}&quot;, alfa);

  alfa.push_str(&quot;, World&quot;);
  println!(&quot;alfa is {}&quot;, alfa);

}</code></pre>
<h3 id="code-runner-84"><a class="header" href="#code-runner-84">CODE RUNNER</a></h3>
<pre><pre class="playground"><code class="language-rust  editable  CODE1"></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="moving-string"><a class="header" href="#moving-string">Moving String</a></h1>
<p>Trying to do this won't work (via https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html)</p>
<pre><code class="language-rust  noplayground ">fn main() {

  let alfa = String::from(&quot;widget&quot;);
  let bravo = alfa;

  println!(&quot;alfa {} - bravo {}&quot;, alfa, bravo);

}</code></pre>
<p>We'll look at the error message on the next page, but for now, here's what will work.</p>
<p>TKTKTK</p>
<h4 id="source-code-87"><a class="header" href="#source-code-87">SOURCE CODE</a></h4>
<pre><code class="language-rust  noplayground  EXAMPLE1">fn main() {

  let alfa = String::from(&quot;widget&quot;);
  let bravo = alfa.clone();

  println!(&quot;alfa {} - bravo {}&quot;, alfa, bravo);

}</code></pre>
<h3 id="code-runner-85"><a class="header" href="#code-runner-85">CODE RUNNER</a></h3>
<pre><pre class="playground"><code class="language-rust  editable  CODE1"></code></pre></pre>
<p>TODO: Write up how integers can be copied with:</p>
<pre><code>let alfa = 7;
let bravo = alfa;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions-placeholder"><a class="header" href="#functions-placeholder">Functions Placeholder</a></h1>
<p>This is a place holder until these
function pages are sorted.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="passing-values-in-functions"><a class="header" href="#passing-values-in-functions">Passing Values In Functions</a></h1>
<p>passing a variable into a function works
the same way as assigning it to a new variable.</p>
<p>this throws an error:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {

  let alfa = String::from(&quot;apple&quot;);

  widget(alfa);

  println!(&quot;alfa {}&quot;, alfa);

}

fn widget(incoming: String) {
  println!(&quot;Got {}&quot;, incoming)
}</code></pre></pre>
<p>TKTKTKT - Talk about how integers can work</p>
<p>this is okay:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {

  let alfa = 7;

  widget(alfa);

  println!(&quot;alfa {}&quot;, alfa);

}

fn widget(incoming: i32) {
  println!(&quot;Got {}&quot;, incoming)
}</code></pre></pre>
<hr />
<p>You can pass a string and get one back
if you want to do that.</p>
<p>But check out references next. Maybe don't
get into passing back right now and just
focus on references.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="function-references"><a class="header" href="#function-references">Function References</a></h1>
<p>You can pass values by reference so the
functions don't take ownership.</p>
<p>TKTKTK The act of using a reference is
called borrowing.</p>
<h4 id="source-code-88"><a class="header" href="#source-code-88">SOURCE CODE</a></h4>
<pre><pre class="playground"><code class="language-rust  editable  EXAMPLE1">fn main() {

  let alfa = String::from(&quot;apple&quot;);

  widget(&amp;alfa);

  println!(&quot;alfa {}&quot;, alfa)

}

fn widget(incoming: &amp;String) {
  println!(&quot;incoming: {}&quot;, incoming)
}

</code></pre></pre>
<h3 id="code-runner-86"><a class="header" href="#code-runner-86">CODE RUNNER</a></h3>
<pre><pre class="playground"><code class="language-rust  editable  CODE1"></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="function-references-cant-be-modified-by-default"><a class="header" href="#function-references-cant-be-modified-by-default">Function References Can't Be Modified By Default</a></h1>
<p>TKTKTKT</p>
<p>This won't work by default. You have to do
the mutalbe version which is on the next
page.</p>
<h4 id="source-code-89"><a class="header" href="#source-code-89">SOURCE CODE</a></h4>
<pre><pre class="playground"><code class="language-rust">fn main() {

  let alfa = String::from(&quot;widget&quot;);

  attempt_change(&amp;alfa);

}

fn attempt_change(value: &amp;String) {
  value.push_str(&quot;update&quot;);
}</code></pre></pre>
<p>TODO: Show the error message.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mutable-function-references"><a class="header" href="#mutable-function-references">Mutable Function References</a></h1>
<p>It is possible to change values in
a function if you make the variable
mutable and pass a mutable reference</p>
<h4 id="source-code-90"><a class="header" href="#source-code-90">SOURCE CODE</a></h4>
<pre><pre class="playground"><code class="language-rust  EXAMPLE1">fn main() {

  let mut alfa = String::from(&quot;widget&quot;);

  println!(&quot;alfa {}&quot;, alfa);

  update_value(&amp;mut alfa);

  println!(&quot;alfa {}&quot;, alfa);

}

fn update_value(value: &amp;mut String) {
  value.push_str(&quot; updated&quot;);
}</code></pre></pre>
<h3 id="code-runner-87"><a class="header" href="#code-runner-87">CODE RUNNER</a></h3>
<pre><pre class="playground"><code class="language-rust  editable  CODE1"></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="only-one-mutable-reference"><a class="header" href="#only-one-mutable-reference">Only One Mutable Reference</a></h1>
<p>You can only make one mutable reference to
a variable.</p>
<p>This will fail:</p>
<h4 id="source-code-91"><a class="header" href="#source-code-91">SOURCE CODE</a></h4>
<pre><pre class="playground"><code class="language-rust">fn main() {

  let mut alfa = String::from(&quot;widget&quot;);

  let bravo = &amp;mut alfa;

  let charlie = &amp;mut alfa;

  println!(&quot;bravo {}&quot;, bravo);
  println!(&quot;charlie {}&quot;, charlie);

}</code></pre></pre>
<p>TODO: show the error message and explain it
on the next page.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scope-for-mutalbe-references"><a class="header" href="#scope-for-mutalbe-references">Scope For Mutalbe References</a></h1>
<p>NOTE: this can probably be moved to
a later part of the book.</p>
<p>This is the earlier example that doesn't
work. If we move the println for
bravo up it does work.</p>
<p>TODO: There is scope
stuff that comes in to play but there's
no explicit scope here so I'm guessing
rust sees that <code>bravo</code> isn't going to
be used anymore after charlie is set
so it uses that for scope?</p>
<pre><pre class="playground"><code class="language-rust">fn main() {

  let mut alfa = String::from(&quot;widget&quot;);

  let bravo = &amp;mut alfa;
  println!(&quot;bravo {}&quot;, bravo);

  let charlie = &amp;mut alfa;
  println!(&quot;charlie {}&quot;, charlie);

}</code></pre></pre>
<p>Look more and the example on this page.</p>
<p>https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mutable-and-immutable-references-cant-be-combined"><a class="header" href="#mutable-and-immutable-references-cant-be-combined">Mutable And Immutable References Can't Be Combined</a></h1>
<p>TODO: Make this a page:</p>
<p>You can have an immutable reference to a mutable variable.</p>
<h4 id="source-code-92"><a class="header" href="#source-code-92">SOURCE CODE</a></h4>
<pre><code class="language-rust  noplayground  EXAMPLE1">fn main() {

  let mut alfa = String::from(&quot;widget&quot;);

  let bravo = &amp;alfa;

  println!(&quot;bravo {}&quot;, bravo)

}
</code></pre>
<h3 id="code-runner-88"><a class="header" href="#code-runner-88">CODE RUNNER</a></h3>
<pre><pre class="playground"><code class="language-rust  editable  CODE1"></code></pre></pre>
<hr />
<p>Testing examples:</p>
<p>Mutable references to immutable variables throw
an error. Show this error.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {

  let alfa = String::from(&quot;widget&quot;);

  let bravo = &amp;mut alfa;

  println!(&quot;bravo {}&quot;, bravo);

}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="todo-1"><a class="header" href="#todo-1">TODO</a></h1>
<p>Things to add to the functions and references.</p>
<p>From:
https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html</p>
<hr />
<p>You can make multiple immutable references
to a mutable value.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
  let mut alfa = String::from(&quot;widget&quot;);

  let bravo = &amp;alfa;

  let charlie = &amp;alfa;

  println!(&quot;bravo {}&quot;, bravo);
  println!(&quot;charlie {}&quot;, charlie);

}</code></pre></pre>
<hr />
<p>You can't have a mutable reference to a mutable variable
at the same time as you already have an immutable one.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {

  let mut alfa = String::from(&quot;widget&quot;);

  let bravo = &amp;alfa;

  let charlie = &amp;alfa;

  let delta = &amp;mut alfa;

  println!(&quot;alfa {}&quot;, alfa);
  println!(&quot;bravo {}&quot;, bravo);
  println!(&quot;charlie {}&quot;, charlie);
  println!(&quot;delta {}&quot;, delta);

}</code></pre></pre>
<hr />
<p>This was referred earlier I think, but this is
confirmation that if rust sees that the values
isn't going to be used anymore it releases the
reference (TODO: Figure out the actual term for
that) and you can use it:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {

  let mut alfa = String::from(&quot;widget&quot;);
  println!(&quot;alfa {}&quot;, alfa);

  let bravo = &amp;alfa;
  println!(&quot;bravo {}&quot;, bravo);

  let charlie = &amp;alfa;
  println!(&quot;charlie {}&quot;, charlie);

  let delta = &amp;mut alfa;
  println!(&quot;delta {}&quot;, delta);

}</code></pre></pre>
<hr />
<p>You can't make a new variable in a function and then
return it. When the function is done, the original
value disappears. Rust, prevents this type of thing
from happening. If you try to run this code, you'll
see the error (TKTKTKT review the error).</p>
<pre><pre class="playground"><code class="language-rust">fn main() {

  let alfa = widget();

  println!(&quot;alfa {}&quot;, alfa);
}

fn widget() -&gt; &amp;String {

  let bravo = String::from(&quot;hello&quot;);

  &amp;bravo

}</code></pre></pre>
<hr />
<p>This works though.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {

  let alfa = widget();

  println!(&quot;alfa {}&quot;, alfa);

}

fn widget() -&gt; String {

  let bravo = String::from(&quot;hello&quot;);

  bravo

}
</code></pre></pre>
<hr />
<p>Rules of references:</p>
<ul>
<li>At any given time, you can have either one
mutable reference or any number of immutable
references.</li>
<li>References must always be valid.</li>
</ul>
<hr />
<p>This shows an early return in a function</p>
<pre><pre class="playground"><code class="language-rust">fn main() {

  let alfa = limit_to_five(3);

  let bravo = limit_to_five(10);

  println!(&quot;alfa {} bravo {}&quot;, alfa, bravo);

}

fn limit_to_five(value: i32) -&gt; i32 {

  if value &gt; 5 {
    return 5
  }

  value

}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="slices-todo"><a class="header" href="#slices-todo">Slices TODO</a></h1>
<hr />
<p>TODO: I often get wires crossed. Mutability and
References are not dependent on each other. Specifically,
the idea of an immutable reference throws me. Potentially
write something up about that.</p>
<hr />
<p>from: https://doc.rust-lang.org/book/ch04-03-slices.html</p>
<p>It's labeled as The Slice Type</p>
<p>Baisc example:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {

  let alfa = String::from(&quot;the quick fox&quot;);

  let bravo = &amp;alfa[4..9];

  println!(&quot;alfa {}&quot;, alfa);
  println!(&quot;bravo {}&quot;, bravo);

}</code></pre></pre>
<hr />
<p>If you're starting at zero, you don't need to put the
zero. These are equivalent.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {

  let alfa = String::from(&quot;the quick fox&quot;);

  let bravo   = &amp;alfa[0..3];

  let charlie = &amp;alfa[..3];

  println!(&quot;bravo {}&quot;, bravo);
  println!(&quot;charlie {}&quot;, charlie);

}</code></pre></pre>
<hr />
<p>The same applies for the end.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {

  let alfa = String::from(&quot;the quick fox&quot;);

  let bravo   = &amp;alfa[9..13];

  let charlie = &amp;alfa[9..];

  println!(&quot;bravo {}&quot;, bravo);
  println!(&quot;charlie {}&quot;, charlie);

}</code></pre></pre>
<hr />
<p>There's also a note about array slices here:
https://doc.rust-lang.org/book/ch04-03-slices.html</p>
<p>It looks like this:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {

  let alfa = [3, 5, 7, 9];

  let bravo = &amp;alfa[1..3];

  assert_eq!(bravo, &amp;[5, 7]);

}</code></pre></pre>
<p>but maybe wait until vecs.</p>
<p>Also, we haven't seen assertions yet, and I don't
totally get the refernce to the stand alone array.
or, more to the point, why it's a reference.</p>
<p>This is from the &quot;Other Slices&quot; secition. Need
to revisit once there's a better understanding
of the parts.</p>
<p>Also, we haven't seen assertions yet, and I don't
totally get the refernce to the stand alone array.
or, more to the point, why it's a reference.</p>
<p>This is from the &quot;Other Slices&quot; secition. Need
to revisit once there's a better understanding
of the parts.</p>
<hr />
<p>Look at:
https://doc.rust-lang.org/book/ch04-03-slices.html</p>
<p>For the stuff about literals too and how
you can pass them into functions wiht</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn widget(value: &amp;str) -&gt; &amp;str {}
<span class="boring">}</span></code></pre></pre>
<p>That lets you pass in both <code>&amp;String</code> and
<code>&amp;str</code> values.</p>
<p>This is an example where you can pass literal
references, and String references, and String
slices (which are references by definition)</p>
<pre><pre class="playground"><code class="language-rust">fn main() {

  let alfa = String::from(&quot;the quick fox&quot;);
  let bravo = &quot;the lazy dog&quot;;

  widget(&amp;alfa);
  widget(&amp;alfa[4..9]);

  widget(&amp;bravo);
  widget(&amp;bravo[4..8]);

}

fn widget(value: &amp;str) {

  println!(&quot;Value is {}&quot;, value);

}</code></pre></pre>
<p>Question: does this mean that you should pretty
much always use <code>&amp;str</code> instead of <code>&amp;String</code> for
function parameters?</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="string-literals"><a class="header" href="#string-literals">String literals</a></h1>
<p>Look at the string literals part of
the bottom of this page:</p>
<p>https://doc.rust-lang.org/book/ch04-03-slices.html</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="structs"><a class="header" href="#structs">Structs</a></h1>
<ul>
<li>
<p>NOTE: I make an effort to keep the code blocks
small, but they are going to be growing in size
as we work with more comlex parts of the language.</p>
</li>
<li>
<p>Structs hold data with names associated with them.</p>
</li>
<li>
<p>They are defined with the keyword <code>struct</code> followed
by a name (with Capital_Snake_Case), then a code
block surrounded by <code>{}</code> curly braces.</p>
</li>
<li>
<p>Note the <code>,</code> at the end of the last field.</p>
</li>
<li>
<p>Note that things are called fields.</p>
</li>
</ul>
<p>A struct looks like:</p>
<pre><code class="language-rust  noplayground">struct Widget {
  alfa: bool,
  bravo: i32,
}</code></pre>
<p>The struct definition acts like a template that we
fill in when we &quot;make an instance&quot; of it which
is done by binding it to a variable like this.</p>
<pre><code class="language-rust noplayground">struct Widget {
  alfa: bool,
  bravo: i32,
}

fn main() {
  let thing = Widget {
    alfa: true,
    bravo: 7,
  };
}</code></pre>
<p>Using the values in an instance of a struct is
done using &quot;dot notation&quot; which is the name of
the varialbe then a dot then the name of the
value to use.</p>
<p>Run this one for an example:</p>
<h4 id="source-code-93"><a class="header" href="#source-code-93">SOURCE CODE</a></h4>
<pre><code class="language-rust  noplayground  EXAMPLE1">struct Widget {
  alfa: bool,
  bravo: i32,
}

fn main() {
  let thing = Widget {
    alfa: true,
    bravo: 7,
  };

  println!(&quot;thing.alfa is {}&quot;, thing.alfa);
  println!(&quot;thing.bravo is {}&quot;, thing.bravo);

}</code></pre>
<h3 id="code-runner-89"><a class="header" href="#code-runner-89">CODE RUNNER</a></h3>
<pre><pre class="playground"><code class="language-rust  editable  CODE1"></code></pre></pre>
<hr />
<p>Trying to change a value of a field when the
struct instance is immutable won't work. If
we run this we'll get an error.</p>
<pre><pre class="playground"><code class="language-rust">struct Widget {
  alfa: bool,
}

fn main() {
  let thing = Widget {
    alfa: true,
  };

  thing.alfa = false;

  println!(&quot;thing.alfa is {}&quot;, thing.alfa);

}</code></pre></pre>
<p>The fix is to make the varible mutable by changing:
<code>let thing</code> to <code>let mut thing</code>. Here's the code
with that in place that will work.</p>
<pre><pre class="playground"><code class="language-rust">struct Widget {
  alfa: bool,
}

fn main() {
  let mut thing = Widget {
    alfa: true,
  };

  thing.alfa = false;

  println!(&quot;thing.alfa is {}&quot;, thing.alfa);

}
</code></pre></pre>
<hr />
<p>NOTE: You can't make just some of the fields mutable.
The entire struct has to be made mutable.</p>
<p>But, each instance can be either mutable or immutable.</p>
<pre><pre class="playground"><code class="language-rust">struct Widget {
  alfa: bool,
}

fn main() {
  let thing1 = Widget {
    alfa: true,
  };

  let mut thing2 = Widget {
    alfa: false
  };

  println!(&quot;thing1.alfa is {}&quot;, thing1.alfa);
  println!(&quot;thing2.alfa is {}&quot;, thing2.alfa);

}</code></pre></pre>
<hr />
<p>You have to define each field when you make
a struct (TODO: Verify that's the case or
that there's not another way to do it
where the fields aren't required.) This won't
work:</p>
<pre><pre class="playground"><code class="language-rust">struct Widget {
  alfa: bool,
  bravo: i32,
}

fn main() {

  let thing = Widget {
    alfa: true,
  };

  println!(&quot;thing.alfa is {}&quot;, thing.alfa);

}</code></pre></pre>
<hr />
<p>Creating an instance is an expression which means
it can be returend from a function. This is
a way to set default values for fields. For example
this struct has <code>alfa</code> and <code>bravo</code> fields. We
create a function that takes only an incoming
alfa field and sets a default bravo then
returns the insatance.</p>
<p>Things to point out:</p>
<ul>
<li>The return value of make_thing is <code>Widget</code></li>
</ul>
<pre><pre class="playground"><code class="language-rust">struct Widget {
  alfa: bool,
  bravo: i32,
}

fn main() {

  let thing = make_thing(true);

  println!(&quot;thing.alfa is {}&quot;, thing.alfa);

}

fn make_thing(input_value: bool) -&gt; Widget {

  Widget {
    alfa: input_value,
    bravo: 7,
  }

}</code></pre></pre>
<hr />
<p>It's also possible to name the fields in the input
parenthesis the same things and the field names.
Doing that lets you shorten the instantiation
of the instance field values to just the.</p>
<p>For example, we start with this where we use
<code>alfa: alfa</code>.</p>
<pre><pre class="playground"><code class="language-rust">struct Widget {
  alfa: bool,
}

fn main() {

  let thing = make_thing(true);

  println!(&quot;thing.alfa {}&quot;, thing.alfa);

}

fn make_thing(alfa_value: bool) -&gt; Widget {

  Widget {
    alfa: alfa_value,
  }

}
</code></pre></pre>
<p>And here we can name the input parameter and just
use <code>alfa</code> instead of <code>alfa: alfa_value</code> to set
things:</p>
<pre><pre class="playground"><code class="language-rust">struct Widget {
  alfa: bool,
}

fn main() {

  let thing = make_thing(true);

  println!(&quot;thing.alfa {}&quot;, thing.alfa);

}

fn make_thing(alfa: bool) -&gt; Widget {

  Widget {
    alfa,
  }

}</code></pre></pre>
<h3 id="struct-update-syntax"><a class="header" href="#struct-update-syntax">Struct Update Syntax</a></h3>
<p>This lets us make a new instance with all
the values from a prior instance except
ones that we decide to overwrite.</p>
<p>Things to note:</p>
<ul>
<li><code>..thing1</code> can't have a comma after it.</li>
</ul>
<pre><pre class="playground"><code class="language-rust">struct Widget {
  alfa: i32,
  bravo: i32,
  charlie: i32,
}

fn main() {

  let thing1 = Widget {
    alfa: 3,
    bravo: 5,
    charlie: 7,
  };

  let thing2 = Widget {
    bravo: 100,
    ..thing1
  };

  println!(&quot;thing2.alfa {}&quot;, thing2.alfa);
  println!(&quot;thing2.bravo {}&quot;, thing2.bravo);
  println!(&quot;thing2.charlie {}&quot;, thing2.charlie);

}</code></pre></pre>
<hr />
<h3 id="struct-update-syntax-moves-values"><a class="header" href="#struct-update-syntax-moves-values">Struct Update Syntax Moves Values</a></h3>
<p>Note that the struct update syntax moves values. So,
unless they implement the copy trait (like i32), the
values are moved which means the original can't be
used. For example, this will break.</p>
<pre><pre class="playground"><code class="language-rust">struct Widget {
  alfa: String,
  bravo: bool,
}

fn main() {

  let thing1 = Widget {
    alfa: String::from(&quot;hello&quot;),
    bravo: true,
  };

  let thing2 = Widget {
    bravo: false,
    ..thing1
  };

  println!(&quot;thing1.alfa {}&quot;, thing1.alfa);
  println!(&quot;thing2.alfa {}&quot;, thing2.alfa);

}</code></pre></pre>
<h3 id="update-with-copy-variables"><a class="header" href="#update-with-copy-variables">Update With Copy variables</a></h3>
<p>TODO: Figure out if you want to get into this
here or if you want to push it to later
when you have a deeper conversation about
the heap and the stack. That probably makes
the most sense.</p>
<p>Note that if you overwrite all the variables
that don't implement the copy trait (e.g.
<code>String</code>) you can leave the ones that do (e.g.
<code>i32</code>, and bool). If we take the same struct and <code>thing1</code>
from the prior example but change the <code>String</code>
in <code>alfa</code> instead of the <code>bool</code> in <code>bravo</code> the
program will run properly.</p>
<pre><pre class="playground"><code class="language-rust">struct Widget {
  alfa: String,
  bravo: bool,
}

fn main() {

  let thing1 = Widget {
    alfa: String::from(&quot;hello&quot;),
    bravo: true,
  };

  let thing2 = Widget {
    alfa: String::from(&quot;goodbye&quot;),
    ..thing1
  };

  println!(&quot;thing1.alfa {}&quot;, thing1.alfa);
  println!(&quot;thing2.alfa {}&quot;, thing2.alfa);

}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tuple-structs"><a class="header" href="#tuple-structs">Tuple Structs</a></h1>
<p>These are like regular structs but they don't
have named fields. The values are positional
with only the type defined.</p>
<pre><pre class="playground"><code class="language-rust">struct Widget(i32, f32, bool);

fn main() {

  let alfa = Widget(3, 7.0, true);

  println!(&quot;alfa.1 is {}&quot;, alfa.1);

}
</code></pre></pre>
<hr />
<p>Tuple Structs are useful for setting a type
and passing data to a function without
the need for a full struct.</p>
<pre><pre class="playground"><code class="language-rust">struct Widget (i32, f32, bool);

fn main() {

  let alfa = Widget(3, 7.0, true);

  process_widget(alfa);

}

fn process_widget(widget_input: Widget) {

  println!(&quot;Value is {}&quot;, widget_input.1)

}</code></pre></pre>
<hr />
<p>Unit-Like Structs</p>
<p>NOTE: Move this to later after we've
discussed the Unit type.</p>
<p>These structs can be used to setup a type
that implements traits but holds no data.
There will be a later example of that
that should be combined with this.</p>
<p>(This will have no output as it is right
now)</p>
<pre><pre class="playground"><code class="language-rust">struct Widget;

fn main() {
  let alfa = Widget;
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="debug-derived-trait"><a class="header" href="#debug-derived-trait">Debug Derived Trait</a></h1>
<p>This is from lower on this page:</p>
<p>https://doc.rust-lang.org/book/ch05-02-example-structs.html</p>
<p>TODO: Make sure you've already talked about
the debug print format <code>{:?}</code> and <code>!dbg</code>
and how <code>!dbg</code> takes ownership and then returns
it and prints to <code>stderr</code></p>
<p>You can't print a struct directly.</p>
<pre><pre class="playground"><code class="language-rust">struct Widget { alfa: bool }

fn main() {

  let thing = Widget { alfa: true };

  println!(&quot;thing is {}&quot;, thing);

}</code></pre></pre>
<p>TODO: Show that error</p>
<hr />
<p>The <code>{:?}</code> debug syntax won't work
either.</p>
<pre><pre class="playground"><code class="language-rust">struct Widget { alfa: bool }

fn main() {

  let thing = Widget { alfa: true };

  println!(&quot;thing is {:?}&quot;, thing);

}</code></pre></pre>
<p>TODO: Show the &quot;error[E0277]: <code>Widget</code> doesn't implement
<code>Debug</code>&quot; error.</p>
<hr />
<p>If you add the <code>outter attribute</code> for debugging with:
<code>#[derive(Debug)]</code> it'll allow for <code>{:?}</code> or <code>{:#?}</code>
to output a basic representation of the struct.
(The <code>{:#?}</code>is the same thing as<code>{:?}</code> with a little
nicer formatting and is that's shown here)</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Widget { alfa: bool }

fn main() {

  let thing = Widget { alfa: true };

  println!(&quot;thing is {:#?}&quot;, thing);

}</code></pre></pre>
<hr />
<h3 id="using-dbg"><a class="header" href="#using-dbg">Using <code>!dbg</code></a></h3>
<p>Probably you should just show this for the
debuggin stuff instead of <code>{:?}</code> in
<code>println!()</code> for the default way to do
debugging. TODO: look into the differences
to see about that, but almost certianly
move the <code>{:?}</code> to a later section.</p>
<p>NOTE: this isn't showing up on the playground
possibly because only <code>stdout</code> and not <code>stderr</code>
is returned? Need to look into that.</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Widget { alfa: bool }

fn main() {

  let thing = Widget { alfa: true };

  dbg!(thing);

}</code></pre></pre>
<hr />
<h3 id="use-dbg-around-expressions"><a class="header" href="#use-dbg-around-expressions">Use dbg! Around Expressions</a></h3>
<p>You can use around expressions. This means
you can do things like this (TODO: figure
out if <code>dbg!</code> can output on the rust playground.)</p>
<pre><pre class="playground"><code class="language-rust">fn main() {

  let alfa = 3;
  let bravo = 5;

  let charlie = dbg!(alfa * bravo);

  println!(&quot;charlie is {}&quot;, charlie);

}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="struct-methods"><a class="header" href="#struct-methods">Struct Methods</a></h1>
<p>Struct methods are like functions, but that are attached
to structs. They are put inside an <code>impl</code> keyword code
block that has the same name as the struct they are
for. Here we are using an empty struct and adding
a method that prints out &quot;the quick fox&quot;. (Notice
that the argument <code>&amp;self</code> is being passed to the
<code>fn</code>. That is always the case for methods. (TODO:
talk more about that)</p>
<p>Note that methods are called with <code>()</code>.</p>
<pre><pre class="playground"><code class="language-rust">struct Widget;

impl Widget {
  fn do_output(&amp;self) {
    println!(&quot;the quick fox&quot;);
  }
}

fn main() {
  let thing = Widget;
  thing.do_output();
}</code></pre></pre>
<hr />
<h3 id="using-fields"><a class="header" href="#using-fields">Using fields</a></h3>
<p>This is done by using <code>&amp;self</code> which
is alwasy the first argument passed in</p>
<pre><pre class="playground"><code class="language-rust">struct Widget {
  alfa: bool,
}

impl Widget {

  fn do_output(&amp;self) {
    println!(&quot;alfa is {}&quot;, &amp;self.alfa);
  }

}

fn main() {

  let thing = Widget {
    alfa: true
  };

  thing.do_output();

}</code></pre></pre>
<hr />
<p>In the more advanced section, point out that
<code>&amp;self</code> is shorthand for <code>self: &amp;Self</code> that Rust
provides out of the box.</p>
<hr />
<p>Talks about using methods instead of functions
as some orginaztion and keeping stuff together.</p>
<hr />
<h3 id="passing-values-to-methods"><a class="header" href="#passing-values-to-methods">Passing values to methods</a></h3>
<pre><pre class="playground"><code class="language-rust">struct Widget;

impl Widget {

  fn show_value(&amp;self, value: i32) {
    println!(&quot;Value is {}&quot;, value);
  }

}

fn main() {

  let alfa = Widget;

  alfa.show_value(7);

}</code></pre></pre>
<h3 id="associated-functions"><a class="header" href="#associated-functions">Associated Functions</a></h3>
<p>these are like methods, but don't have '&amp;self'</p>
<p>Maybe push this to later in the book.</p>
<p><code>String::from()</code> is an associated function.</p>
<p>They are often used to make a new instance of the thing
(e.g. with <code>Widget::new</code>) by returning <code>Self</code></p>
<p>The <code>new</code> is not special or a reserved keyword or
otherwise build into the language.</p>
<p>NOTE: Things are normally writtin in the order:
<code>struct</code>, <code>impl</code>, <code>main</code> but this works and is
easier for me to following when I'm making
learning.</p>
<p>The <code>Self</code> in the <code>fn</code> and return value are
aliases to what's named in <code>impl</code> in this
case <code>Widget</code>. You can replace <code>Self</code>
with <code>Widget</code> and it'll still work.</p>
<pre><pre class="playground"><code class="language-rust">fn main () {
  let thing = Widget::new(7);

  println!(&quot;thing.alfa {}&quot;, thing.alfa);
  println!(&quot;thing.bravo {}&quot;, thing.bravo);
}

impl Widget {
  fn new(load_value: i32) -&gt; Self {
    Self {
      alfa: load_value,
      bravo: load_value,
    }
  }
}

struct Widget  {
  alfa: i32,
  bravo: i32,
}</code></pre></pre>
<hr />
<p>Associated function also provide for
name spcing. Here to stucts are given
an associated function with the name
<code>my_value</code>. Since both are called with
their struct names think get namespaced
and they don't conflict.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
  Alfa::show_message();
  Bravo::show_message();
}

impl Alfa {
  fn show_message() {
    println!(&quot;alfa&quot;)
  }
}

impl Bravo {
  fn show_message() {
    println!(&quot;bravo&quot;)
  }
}

struct Alfa;
struct Bravo;</code></pre></pre>
<hr />
<h3 id="multiple-impl-blocks"><a class="header" href="#multiple-impl-blocks">Multiple impl blocks</a></h3>
<p>You can make multilpe <code>impl</code> blocks. The book
says there's not a real reason to do that for the
most part. There will be a later case with
generics types and traits. But kick this out
until then.</p>
<pre><pre class="playground"><code class="language-rust">struct Widget;

impl Widget {
  fn alfa(&amp;self) {
    println!(&quot;alfa&quot;);
  }
}

impl Widget {
  fn bravo(&amp;self) {
    println!(&quot;bravo&quot;);
  }
}

fn main() {

  let thing = Widget;

  thing.alfa();
  thing.bravo();
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enums"><a class="header" href="#enums">Enums</a></h1>
<p>NOTE: It's possibe that you don't want to
show code until you show the <code>if let</code> or the
match stuff for how to get something out.</p>
<hr />
<p>Enums let you define something as one out of
a possible set of values.</p>
<p>Anything that's valid as a stuct is also
valid as an enum.</p>
<p>these are the base examples from the
book, which I don't really understand
becuase they don't really show how to
use them.</p>
<pre><pre class="playground"><code class="language-rust">enum IpAddrKind {
  V6,
  V4
}

fn main() {
  let four = IpAddrKind::V4;
  println!(&quot;here&quot;);
}</code></pre></pre>
<p>That sets the type to <code>ipAddrKind</code> overall.
This lets us do:</p>
<pre><code class="language-rust  noplayground">fn route(ip_kind, IpAddrKind) {}</code></pre>
<p>The book goes on to show this</p>
<pre><pre class="playground"><code class="language-rust">enum IpAddr {
  V4(String),
  V6(String)
}

fn main() {

  let home = IpAddr::V4(String::from(&quot;127.0.0.1&quot;));
  let loopback = IpAddr::V4(String::from(&quot;::1&quot;));

}</code></pre></pre>
<hr />
<p>TODO: Add impl function being assocaited with
an enum. This is based off this:
https://doc.rust-lang.org/book/ch06-01-defining-an-enum.html
Need to check and make sure this is a standard
way to do stuff (becuse there wasn't a full
example in the book.)</p>
<p>NOTE: This is not a good example.</p>
<pre><pre class="playground"><code class="language-rust">enum Widget {
  Alfa,
  Bravo,
}

impl Widget {
  fn show_value(&amp;self) {
    println!(&quot;Widget&quot;);
  }
}

fn main() {

  let thing1 = Widget::Alfa;
  let thing2 = Widget::Bravo;

  thing1.show_value();
  thing2.show_value();

}</code></pre></pre>
<hr />
<p>This is an attempt to make an example that's
easier to understand what's going on.</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
enum Widget {
  Alfa { value: i32 },
  Bravo { value: f32}
}

fn main() {
  let thing1 = Widget::Alfa {value: 7};
  let thing2 = Widget::Bravo {value: 3.4};

  println!(&quot;here {:?}&quot;, thing1.value);
}</code></pre></pre>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="enum-type-aliases"><a class="header" href="#enum-type-aliases">Enum Type Aliases</a></h1>
<p>NOTE: This is the first type aliases things
that showed up in Rust by example. Not sure
if it should be moved to a generic type
aliases page or not yet.</p>
<p>Aliase can be used if you've got a long name
and want to make it easier to use.</p>
<p>NOTE: This doesn't produce any output</p>
<pre><pre class="playground"><code class="language-rust">enum ThisHasLotsOfLettersAndIsTooLong {
  Alfa,
  Bravo,
}

type Shorter = ThisHasLotsOfLettersAndIsTooLong;

fn main() {

  let thing = Shorter::Alfa;

  match thing {
    Shorter::Alfa =&gt; println!(&quot;Got Alfa&quot;),
    Shorter::Bravo =&gt; println!(&quot;Got Bravo&quot;),
  }

}</code></pre></pre>
<hr />
<p>Shorter names can be done in <code>impl</code> blocks.
This happens automatically with <code>Self</code>
(which was mentioned before. TBD on if you
need this here too, but probably works to
make it explict if you reference the earlier
stuff with structs or whatever it was)</p>
<p>(Of course, this is only showing the change
inside the <code>impl</code>. Guess you'd want to do
<code>type</code> as well for the other one.)</p>
<pre><pre class="playground"><code class="language-rust">enum ThisHasLotsOfLettersAndIsTooLong {
  Add,
  Subtract,
}

impl ThisHasLotsOfLettersAndIsTooLong {
  fn run(&amp;self, x: i32, y: i32) -&gt; i32 {
    match self {
      Self::Add =&gt; x + y,
      Self::Subtract =&gt; x - y,
    }
  }
}

fn main() {

  let alfa = ThisHasLotsOfLettersAndIsTooLong::Add;
  println!(&quot;Addition {}&quot;, alfa.run(3, 4));

  let bravo = ThisHasLotsOfLettersAndIsTooLong::Subtract;
  println!(&quot;Subtraction {}&quot;, bravo.run(4, 3));

}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="match"><a class="header" href="#match">match</a></h1>
<p>Example from the book (with some more
code so it actually does something)</p>
<pre><pre class="playground"><code class="language-rust">enum Coin {
  Penny,
  Nickel,
  Dime,
  Quarter,
}

fn value_in_cents(coin: Coin) -&gt; u8 {
  match coin {
    Coin::Penny =&gt; 1,
    Coin::Nickel =&gt; 5,
    Coin::Dime =&gt; 10,
    Coin::Quarter =&gt; 25,
  }
}

fn main() {

  let my_coin = Coin::Nickel;

  println!(&quot;I have {} cents&quot;, value_in_cents(my_coin));

}</code></pre></pre>
<hr />
<p>Make a note that you can put <code>{}</code> for the code blocks,
but it's usually not done if it fits on one line.</p>
<hr />
<p>This is a basic way to use match to do
something based off the type of enum
that got created.</p>
<pre><pre class="playground"><code class="language-rust">enum Widget {
  Alfa,
  Bravo
}

fn display_variant(value: Widget) {
  match value {

    Widget::Alfa =&gt; {
      println!(&quot;kind is Widget::Alfa&quot;);
    },

    Widget::Bravo =&gt; {
      println!(&quot;kind is Widget::Bravo&quot;);
    }

  }
}


fn main() {

  let thing1 = Widget::Alfa;
  display_variant(thing1);

  let thing2 = Widget::Bravo;
  display_variant(thing2);

}</code></pre></pre>
<hr />
<p>Here's anothe example where you pull values
out and bind them so you can use them. This
is one way to get data out of an enum. (I
think <code>if let</code> is another way. Not sure if there
are other ways.)</p>
<pre><pre class="playground"><code class="language-rust">enum Widget {
  Alfa,
  Bravo(String),
  Charlie { value: i32 },
}

fn show_report(item: Widget) {
  match item {
    Widget::Alfa =&gt; {
      println!(&quot;It's Alfa&quot;);
    },
    Widget::Bravo(text) =&gt; {
      println!(&quot;It's Bravo with {}&quot;, text);
    },
    Widget::Charlie { value } =&gt; {
      println!(&quot;It's Charlie with {}&quot;, value);
    },
  }
}

fn main() {
  let item1 = Widget::Alfa;
  show_report(item1);

  let item2 = Widget::Bravo(String::from(&quot;hello&quot;));
  show_report(item2);

  let item3 = Widget::Charlie { value: 7 };
  show_report(item3);

}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scope"><a class="header" href="#scope">Scope</a></h1>
<p>Scope example that works, this we'll
see it break on the next page.</p>
<h4 id="source-code-94"><a class="header" href="#source-code-94">SOURCE CODE</a></h4>
<pre><code class="language-rust  noplayground  EXAMPLE1">fn main() {

  let alfa = 1;

  {
    let bravo = 2;
    println!(&quot;bravo {}&quot;, bravo);
  }

  println!(&quot;alfa {}&quot;, alfa);

}</code></pre>
<h3 id="code-runner-90"><a class="header" href="#code-runner-90">CODE RUNNER</a></h3>
<pre><pre class="playground"><code class="language-rust  editable  CODE1"></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scope-error"><a class="header" href="#scope-error">Scope Error</a></h1>
<p>Intentional error. Look at the
message on the next page.</p>
<h4 id="source-code-95"><a class="header" href="#source-code-95">SOURCE CODE</a></h4>
<pre><code class="language-rust  noplayground  EXAMPLE1">fn main() {

  let alfa = 1;

  {
    let bravo = 2;
    println!(&quot;bravo {}&quot;, bravo);
  }

  println!(&quot;alfa {} - bravo {}&quot;, alfa, bravo);

}</code></pre>
<h3 id="code-runner-91"><a class="header" href="#code-runner-91">CODE RUNNER</a></h3>
<pre><pre class="playground"><code class="language-rust  editable  CODE1"></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scope-error-message"><a class="header" href="#scope-error-message">Scope Error Message</a></h1>
<p>TKTKTK</p>
<pre><code class="language-rust  noplayground">   Compiling playground v0.0.1 (/playground)
error[E0425]: cannot find value `bravo` in this scope
  --&gt; src/main.rs:10:40
   |
10 |   println!(&quot;alfa {} - bravo {}&quot;, alfa, bravo);
   |                                        ^^^^^ not found in this scope

For more information about this error, try `rustc --explain E0425`.
error: could not compile `playground` due to previous error</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="guildlines"><a class="header" href="#guildlines">Guildlines</a></h1>
<p>These are not hard rules. They are guidelines.
Staying from them when it makes sense makes
total sense.</p>
<ul>
<li>
<p>Get to code that actually does
something as fast as possible</p>
</li>
<li>
<p>Make the initial explinations as short
as possible</p>
</li>
<li>
<p>Focus on <em>how</em> not <em>why</em> at the start.</p>
</li>
<li>
<p>Maybe: cycle through concepts (e.g varaibles
with numbers, then if/then, then variables
with booleans, then if/else., the variables
with Strings, then if/else if/else)</p>
</li>
<li>
<p>You don't have to explain everything all
at once. (e.g. you don't have to explain
floats in order to talk about integers and
you don't have to talk about the bits an
integer can take up or the signed vs
unsigned versions when you first start.)</p>
</li>
<li>
<p>Run off the idea that folks will go through
the entire book. So, you don't need to explain
everything all at once. (see also the other note
about that)</p>
</li>
<li>
<p>Only show one way to do something (e.g. with ranges
instead of showing <code>(1..10)</code> and then explaining that
if you want to actually get to ten, just show <code>(1..=10)</code>.</p>
</li>
<li>
<p>Don't worry too much about explaing the syntax. That is:
Show. Don't Tell.</p>
</li>
<li>
<p>Avoid talking about what you'll show later. Wait until
you get there. (This is a continuation of show don't tell)</p>
</li>
<li>
<p>Avoid statements like &quot;which we haven't talked about yet&quot;.
If the person thinks about it at all, they'll know that's the
case so there's littl point in mentioning it.</p>
</li>
<li>
<p>Don't dig into every possible option at the start with edge
cases. e.g. &quot;In Rust, the <code>main()</code> function is used to kick
things off&quot; works find without having to. &quot;In most programs,
except for these types when its... whatever&quot;) It's like
taking an 80/20 thing where the statement needs to be accurate
but not all inclusive. Details of the different cases can
be dealt with later.</p>
</li>
<li>
<p>You can also use lanage like &quot;basic variables are defined like&quot;
instead of &quot;variables are defined like&quot;.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="work-in-progress"><a class="header" href="#work-in-progress">Work In Progress</a></h1>
<p>This site is a work in progress. Everything
prior to this page is in pretty good shape
for a first iteration.</p>
<p>The pages that follow contain drafts, and
scratch notes and aren't in order. They'll
shift around and solidify. You're welcome
to check them out, but please keep that in
mind.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="todo-list"><a class="header" href="#todo-list">TODO List</a></h1>
<h2 id="stream"><a class="header" href="#stream">Stream</a></h2>
<ul>
<li>
<p>[] Add button to disable live typo detection.</p>
</li>
<li>
<p>Add two buttons into the Code Runner that let you
click them to decide to Type or to decide to
Copy and Run the code directly.</p>
</li>
<li>
<p>Move the run button below the Code Runners</p>
</li>
<li>
<p>Add spacing to the code lines so you don't have to
put spacer lines between all of them.</p>
</li>
<li>
<p>Add a button to copy the text automatically, maybe
you could make that the thing where when you click in
you click inside for copy the text or type the text.
(because you have to click in anyway unless you tab
in so you should handle tabbing in too)</p>
</li>
<li>
<p>Add styles to <code>txt</code> code fences.</p>
</li>
<li>
<p>Turn off whatever is overriding the default scroll bars.</p>
</li>
<li>
<p>See if you can turn off whatever is making the TOC
sidebar nav jump to center the items so that it stays
with where you had it. (Probably requrie setting a cookie
and reading it?)</p>
</li>
</ul>
<h2 id="other"><a class="header" href="#other">Other</a></h2>
<ul>
<li>
<p>Verify that the generic term statement can be used
to describe expressions (e.g. &quot;an <code>if</code> statement is
an expression&quot;)</p>
</li>
<li>
<p>Is it possible to make the book dynamic in some
way, even if it's just manually. Like a setting where
you can select if you've got any programming experience
or not and if not you get extra text and maybe some
variations in the main text.</p>
</li>
<li>
<p>What if there was a spaced repetition thing
built into the site with programs to run that helped
work on the parts you weren't as sure about.</p>
</li>
<li>
<p>Put in fun things to do and see for the different
parts that you go through as options?</p>
</li>
<li>
<p>What if there were different versions of the book
with different exmample variable names (e.g. if you
want to have animals, or colors, or nato alphabet)
Or, maybe not different versions, but like settings
so you could control things.</p>
</li>
<li>
<p>Maybe don't use anything that's stored on the
stack for the first part of the book? Introduce
String and Vec instead of string literals and arrays.
That way you don't have to talk about what has to
be borrowed and what doesn't require it.</p>
</li>
<li>
<p>Add note about how things can move to differnt lines
and still be the same expression or statement.</p>
</li>
<li>
<p>Add something so if you hit the run button
when there's nothing in the code running it asks
you if you want to type stuff in or copy it directly?</p>
</li>
<li>
<p>Add a button or link to copy the source code
into the code runner directly. (do that in addtion to the
run check to make sure there's code in the code editor)</p>
</li>
<li>
<p>Make an early example of doing <code>2+2</code>
in the variables chapter.</p>
</li>
<li>
<p>Figure out where to put Statements
and Expressions.</p>
</li>
<li>
<p>Scope</p>
</li>
<li>
<p>Comments</p>
</li>
<li>
<p>Rust does not try to convert non-boolean types to booleans</p>
</li>
<li>
<p>String literals</p>
</li>
<li>
<p>Come up with some example programs to use
as full examples at the end of each section.</p>
</li>
<li>
<p>Talk about the Rust Prelude: https://doc.rust-lang.org/std/prelude/index.html</p>
</li>
<li>
<p>Talkd about the Rust editions</p>
</li>
<li>
<p>Talk about the <code>&amp;str</code> slice type.</p>
</li>
<li>
<p>Talk about derived traits.</p>
</li>
<li>
<p>Talk about how structs and enums are keys to stuff.</p>
</li>
</ul>
<hr />
<p>Put in a note about if you get this error it
probably means you didn't put code in the code runner:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>   Compiling playground v0.0.1 (/playground)
error[E0601]: `main` function not found in crate `playground`
  |
  = note: consider adding a `main` function to `src/main.rs`

For more information about this error, try `rustc --explain E0601`.
error: could not compile `playground` due to previous error
<span class="boring">}</span></code></pre></pre>
<hr />
<p>Comman error:</p>
<p>Compiling playground v0.0.1 (/playground)
error[E0615]: attempted to take value of method <code>do_output</code> on type <code>Widget</code>
--&gt; src/main.rs:15:9
|
15 | thing.do_output;
| ^^^^^^^^^ method, not a field
|
help: use parentheses to call the method
|
15 | thing.do_output();
| ++</p>
<p>For more information about this error, try <code>rustc --explain E0615</code>.
error: could not compile <code>playground</code> due to previous error</p>
<hr />
<p>Using <code>()</code> instead of <code>{}</code></p>
<p>Compiling playground v0.0.1 (/playground)
error: expected identifier, found keyword <code>true</code>
--&gt; src/main.rs:16:28
|
16 | let thing = Widget(alfa: true);
| ^^^^ expected identifier, found keyword
|
help: escape <code>true</code> to use it as an identifier
|
16 | let thing = Widget(alfa: r#true);
| ++</p>
<p>error: invalid <code>struct</code> delimiters or <code>fn</code> call arguments
--&gt; src/main.rs:16:15
|
16 | let thing = Widget(alfa: true);
| ^^^^^^^^^^^^^^^^^^
|
help: if <code>Widget</code> is a struct, use braces as delimiters
|
16 | let thing = Widget { alfa: true };
| ~ ~
help: if <code>Widget</code> is a function, use the arguments directly
|
16 - let thing = Widget(alfa: true);
16 + let thing = Widget(true);
|</p>
<p>error[E0070]: invalid left-hand side of assignment
--&gt; src/main.rs:8:16
|
8 | &amp;self.alfa = false
| ---------- ^
| |
| cannot assign to this expression</p>
<p>For more information about this error, try <code>rustc --explain E0070</code>.
error: could not compile <code>playground</code> due to 3 previous errors</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="statements-and-expressions"><a class="header" href="#statements-and-expressions">Statements and Expressions</a></h1>
<p>From: https://doc.rust-lang.org/book/ch03-03-how-functions-work.html</p>
<blockquote>
<p>Statements are instructions that perform some action and do not return a value.
Expressions evaluate to a resultant value. Let’s look at some examples.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="constants"><a class="header" href="#constants">Constants</a></h1>
<p>There's another type of variable besides
mutable and immutable. They're called &quot;constants&quot;.</p>
<p>Constants are like immutable variables with a
few extra criteria. We've covered enough to
get the idea for the first three:</p>
<ol>
<li>They are defined using the <code>const</code> keyword
instead of <code>let</code></li>
<li>The <code>mut</code> keyword can't be used when creating them</li>
<li>Names should always be in UPPER_SNAKE_CASE
by convention.</li>
</ol>
<p>These next three criteria require some knowledge we
haven't gotten to yet, We'll touch on them in the next
few pages.</p>
<ol>
<li>Constants can be declared in global scope (which will
see on the next page)</li>
<li>They must have a type annotation (e.g. the <code>i32</code>
in the example below which is coming up).</li>
<li>They must be set to something determined at compile
time (which we'll also get to shortly)</li>
</ol>
<pre><code class="language-rust  noplayground  EXAMPLE1">fn main() {
  const ALFA: i32 = 100;
  println!(&quot;Alfa {ALFA}&quot;);
}</code></pre>
<h4 id="code-runner-92"><a class="header" href="#code-runner-92">CODE RUNNER</a></h4>
<pre><pre class="playground"><code class="language-rust  editable  CODE1"></code></pre></pre>
<hr />
<h3 id="todo-2"><a class="header" href="#todo-2">TODO</a></h3>
<ul>
<li>Examine moving constants to a points
after you've talked about scope and types.
Probably that makes the most sense.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="constants-in-the-global-scope"><a class="header" href="#constants-in-the-global-scope">Constants In The Global Scope</a></h1>
<p>Here's the previous example we used to
demonstrate a constant.</p>
<pre><code class="language-rust  noplayground">fn main() {
  const ALFA: i32 = 100;
  println!(&quot;Alfa {ALFA}&quot;);
}</code></pre>
<p>The <code>const</code> and <code>println!()</code> statements are
between the <code>{</code> and <code>}</code> of the <code>main()</code> function.
The terminology used for this is to say
those statements are in the main()
function's &quot;scope&quot;.</p>
<p>Scope is like a one-way wrapper where:</p>
<ol>
<li>Anything that's in a surround scope can be
be accessed by what's inside the inner scope, but</li>
<li>Anything inside the scope can't be accessed by
anything outside of it.</li>
</ol>
<p>The <code>main()</code> function's scope is clearly delimited by
the <code>{</code> and <code>}</code>. There's another scope surrounding it
in our program that's invisible. It's what's called the
&quot;global&quot; scope. It begins at the start of the source code
and goes all the way to the end encompassing everything
in between.</p>
<p>What this means is that we can move the assignment for our
<code>ALFA</code> constant above the definition of the <code>main()</code>
function like this:</p>
<h4 id="source-code-96"><a class="header" href="#source-code-96">SOURCE CODE</a></h4>
<pre><code class="language-rust  noplayground  EXAMPLE1">const ALFA: i32 = 100;

fn main() {
  println!(&quot;Alfa {ALFA}&quot;);
}</code></pre>
<h4 id="code-runner-93"><a class="header" href="#code-runner-93">CODE RUNNER</a></h4>
<pre><pre class="playground"><code class="language-rust  editable  CODE1"></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="types-required"><a class="header" href="#types-required">Types Required</a></h1>
<p>TODO: Fill out this page with notes
on types being required.</p>
<p>TBD on the content based of if this
gets moved to after types have
been covered or if it stays before
them.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compile-time"><a class="header" href="#compile-time">Compile Time</a></h1>
<p>TODO: Fill out this page with notes
on how stuff need to be defined
in a way that it can be determined
at compile time.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="shadowing-variables"><a class="header" href="#shadowing-variables">Shadowing Variables</a></h1>
<h2 id="immutable-variables-cant-be-changed"><a class="header" href="#immutable-variables-cant-be-changed">Immutable Variables Can't Be Changed</a></h2>
<p>Trying to update the value of an immutable
variable results in an error. This code sets
an initial immutable value with <code>let alfa = 3</code>
and then tries to update it with <code>alfa = 5</code> which
causes an error.</p>
<p>Click Run to see an example of what that looks like.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[allow(unused_variables)]
</span><span class="boring">#[allow(unused_assignments)]
</span>fn main() {
  let alfa = 3;
  alfa = 5;
}</code></pre></pre>
<h2 id="shadowing-variables-works"><a class="header" href="#shadowing-variables-works">Shadowing Variables Works</a></h2>
<p>While you can't update an immutable variable,
you can define a new one with the same name.
This is called shadowing.</p>
<p>Enter and run this code for an example</p>
<pre><code class="language-rust  noplayground  EXAMPLE1">fn main() {
  let alfa = 3;
  println!(&quot;The value is {alfa}&quot;);

  let alfa = 5;
  println!(&quot;The value is {alfa}&quot;);
}</code></pre>
<h4 id="code-editor"><a class="header" href="#code-editor">CODE EDITOR</a></h4>
<pre><pre class="playground"><code class="language-rust  editable  CODE1"></code></pre></pre>
<h4 id="todo-3"><a class="header" href="#todo-3">TODO</a></h4>
<ul>
<li>Come up with examples of when you might want
to shadow a variable (changing type might be
one, but I don't know yet why you would do
that instead of making a new variable)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="shadowing-variables-in-scope"><a class="header" href="#shadowing-variables-in-scope">Shadowing Variables In Scope</a></h1>
<p>Shadowing a variable only applies to the scope
that the shadowing happens in. If you bind
a variable in one scope, then shadow it in a child
scope the new version of the variable
will be used in that scope. For example:</p>
<pre><code class="language-rust  noplayground">fn main() {
  let alfa = 3;
  println!(&quot;The value is {alfa}&quot;);

  {
    let alfa = 5;
    println!(&quot;The value is {alfa}&quot;);
  }

}</code></pre>
<pre><code class="language-txt">The value is 3
The value is 5
</code></pre>
<p>If you then exist the child scope and
use the variable name in the original
scope it returns to the original version.</p>
<pre><code class="language-rust  noplayground  EXAMPLE1">fn main() {
  let alfa = 3;
  println!(&quot;The value is {alfa}&quot;);

  {
    let alfa = 5;
    println!(&quot;The value is {alfa}&quot;);
  }

  println!(&quot;The value is {alfa}&quot;);
}</code></pre>
<p>Enter this program and run it to see the output.</p>
<h4 id="code-editor-1"><a class="header" href="#code-editor-1">CODE EDITOR</a></h4>
<pre><pre class="playground"><code class="language-rust  editable  CODE1"></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="shadowing-variables-to-change-type"><a class="header" href="#shadowing-variables-to-change-type">Shadowing Variables To Change Type</a></h1>
<p>Shadowing variables allows you to
change their type. That's something you can't
do with a regular mutable variable (i.e. one
defined with <code>let mut</code>). For example, this code
tries to change from a string to a number.
Run it and you'll see the error message.</p>
<pre><pre class="playground"><code class="language-rust EXAMPLE1">fn main() {
  let mut alfa = &quot;example&quot;;
  alfa = 7;
}</code></pre></pre>
<p>Using shadowed variables to change the type
in a way that works looks like this:</p>
<pre><code class="language-rust  noplayground">fn main() {
  let alfa = &quot;example&quot;;
  let alfa = 7;
  println!(&quot;The value is {alfa}&quot;);
}</code></pre>
<h4 id="code-editor-2"><a class="header" href="#code-editor-2">CODE EDITOR</a></h4>
<pre><pre class="playground"><code class="language-rust editable CODE1"></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="characters"><a class="header" href="#characters">Characters</a></h1>
<p>NOTE: This was originally right after booleans in
the early Data Types chapter. I'm moving it
out for now because I rarely see <code>char</code> used
independently. We'll address in a later section.</p>
<hr />
<p>The <code>char</code> type in Rust holds a single character. Variables
of the <code>char</code> type are defined with single quotes. They can
be set implicitly like this:</p>
<pre><code class="language-rust  noplayground">let alfa = 'a';</code></pre>
<p>Or explicitly like this:</p>
<pre><code class="language-rust  noplayground">let bravo: char = 'b';</code></pre>
<p>Here's the explicit version in a
full program:</p>
<h4 id="source-code-97"><a class="header" href="#source-code-97">SOURCE CODE</a></h4>
<pre><code class="language-rust  noplayground  EXAMPLE1">fn main () {
  let charlie: char = 'c';
  println!(&quot;Value {charlie}&quot;);
}</code></pre>
<h4 id="code-runner-94"><a class="header" href="#code-runner-94">CODE RUNNER</a></h4>
<pre><pre class="playground"><code class="language-rust  editable  CODE1"></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="destructuring-tuples"><a class="header" href="#destructuring-tuples">Destructuring Tuples</a></h1>
<p>https://doc.rust-lang.org/book/ch03-02-data-types.html#the-tuple-type</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="adding-values-to-tuples"><a class="header" href="#adding-values-to-tuples">Adding Values To Tuples</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="arrays"><a class="header" href="#arrays">Arrays</a></h1>
<hr />
<p>NOTE: Arrays are covered in chapter 3 of
The Rust Book. I'm putting them later based
off the sentence &quot;If you're unsure whether
to use an array or a vector, chances are you
should use a vector.</p>
<hr />
<p>Arrays are like tuples. They're containers
that hold a collection of values. Arrays
are different from tuples in two ways:</p>
<ol>
<li>
<p>Every value the contain must be of
the same type.</p>
</li>
<li>
<p>The number of items in an array is set
when the array is created and cannot be
changed.</p>
</li>
</ol>
<p>Arrays are created with square brackets. The
format the defines them is the type followed
by a semicolon then the number of items in
the array. The format looks like this for
an array of three integers.</p>
<pre><code class="language-rust noplayground">let alfa: [i32, 3] = [3, 5, 7];</code></pre>
<p>Accessing the elements of an array is
done using the name of the array followed
by the desired values index number
surrounded by square brackets.</p>
<pre><code class="language-rust noplayground">println!(&quot;Value {}&quot;, alfa[0]);</code></pre>
<p>Putting those parts together we get</p>
<h4 id="source-code-98"><a class="header" href="#source-code-98">SOURCE CODE</a></h4>
<pre><code class="language-rust  noplayground  EXAMPLE1">fn main() {

  let alfa: [i32; 3] = [3, 5, 7];

  println!(&quot;1st {}&quot;, alfa[0]);
  println!(&quot;2nd {}&quot;, alfa[1]);
  println!(&quot;3rd {}&quot;, alfa[2]);

}</code></pre>
<h4 id="code-runner-95"><a class="header" href="#code-runner-95">CODE RUNNER</a></h4>
<pre><pre class="playground"><code class="language-rust  editable  CODE1"></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="statements-and-expressions-1"><a class="header" href="#statements-and-expressions-1">Statements And Expressions</a></h1>
<p>The <code>widget</code> function in the last example
looked like this:</p>
<pre><code class="language-rust noplayground">fn widget() -&gt; i32 {
  5 + 5
}</code></pre>
<p>I bring this up to point out that there is
no <code>;</code> after the <code>5 + 5</code>. This is different
than all the other lines we've seen
in functions so far. For example:</p>
<pre><code class="language-rust noplayground">println!(&quot;Hello, World&quot;);</code></pre>
<p>The reason for this difference is because
Rust functions are made up of two types
of things: Statements and Expressions.</p>
<p>From The Rust Book:</p>
<ul>
<li>Statements are instructions that perform
some action and do not return a value.</li>
<li>Expressions evaluate to a resultant value.</li>
</ul>
<p>Said another way, expressions give you something
back. Statements don't.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="option-type"><a class="header" href="#option-type">Option Type</a></h1>
<p>TKTKTKTKT</p>
<p>There's some stuff here:</p>
<p>https://doc.rust-lang.org/book/ch06-01-defining-an-enum.html</p>
<p>Need to really figure out how to use it before
trying to make an example (I don't understand the ones
in the book)</p>
<p>More stuff on this page:</p>
<p>https://doc.rust-lang.org/book/ch06-02-match.html</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="prerequisets"><a class="header" href="#prerequisets">Prerequisets</a></h1>
<p>This site assumes you know the following:</p>
<ul>
<li>What immutable means.</li>
<li>What it means to assign a variable.</li>
<li>What keywords in a language are</li>
</ul>
<h3 id="todo-4"><a class="header" href="#todo-4">TODO</a></h3>
<ul>
<li>Provide links for how to learn all the above.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="about-the-site"><a class="header" href="#about-the-site">About The Site</a></h1>
<p><strong>DRAFT</strong></p>
<p>I started learning Rust with The Rust Book.
It was too much for me. There's too much explanation
and not enough code for the way I learn.</p>
<p>Short examples work better for me. Just a few lines of
code with no comments intertwined.</p>
<p>Documenting what I'm learning is another big part of
how I figure things out. This site combines both things.
It's a collection of refined examples
based off The Rust Book and Rust By Example with my
write ups.</p>
<p>I'm publishing it to help other folks who learn the
way I do.</p>
<h2 id="notes"><a class="header" href="#notes">NOTES</a></h2>
<ul>
<li>This is a work in progress. It's not even
a full first draft yet.</li>
<li>I'm filling out that pages, but they aren't in
order yet.</li>
<li>Most examples have a CODE EDITOR under them
where you can type the code and run it. That's
been very helpful for me.</li>
<li>I've suppressed some warnings that would
require making examples more complicated. None
of them effect functionality and we'll cover
them specifically in their own chapter.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="terminology"><a class="header" href="#terminology">Terminology</a></h1>
<p>Terms to define</p>
<ul>
<li>argument</li>
<li>assign</li>
<li>bind</li>
<li>compiled</li>
<li>execute</li>
<li>function</li>
<li>keyword</li>
<li>main()</li>
<li>parameter</li>
<li>run</li>
<li>statement</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="typo-test"><a class="header" href="#typo-test">Typo Test</a></h1>
<pre><code class="language-rust noplayground EXAMPLE1">fn main() {

  println!(&quot;alfa&quot;);

}</code></pre>
<pre><pre class="playground"><code class="language-rust editable CODE1"></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="work-in-progress-1"><a class="header" href="#work-in-progress-1">Work In Progress</a></h1>
<p>This site is a build-in-public project.
It's still a very early work in progress.</p>
<p>I'm working to make sure everything is
accurate, but there's lots of stuff
that's out of order and more stuff missing.</p>
<p>All that's to say, it's not ready to go
yet, but feel free to poke around.</p>
<hr />
<p>Other notes to drop in.</p>
<ul>
<li>
<p>My source materials are <a href="https://doc.rust-lang.org/book/">The Rust Programming Language</a>
(aka The Rust Book), <a href="https://doc.rust-lang.org/rust-by-example/">Rust By Example</a>,
<a href="https://github.com/rust-lang/rustlings">Rustlings</a>,
and <a href="https://www.rustadventure.dev/">Rust Adventure</a>. I'm pulling what I learn
from all those places and making the examples you see here</p>
</li>
<li>
<p>Reading this site like a book without typing
is perfectly acceptable. But, I think you'll get the most
out of it by actually typing in the examples (and making all
the typos that includes)</p>
</li>
<li>
<p>You don't need to have Rust installed to use the site. All
the examples are compiled and run directly in the browser
via <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021">The Rust Playground</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="turning-off-warnings"><a class="header" href="#turning-off-warnings">Turning Off Warnings</a></h1>
<p>This code produce the two warnings and one
error on the previous page.</p>
<pre><code class="language-rust  noplayground">fn main() {
  let alfa = 7;
  alfa = 9;
}</code></pre>
<p>All we care about right now is the error message.
Rust provides as way to suppress warnings (TODO:
find the name of these things, &quot;directives&quot;, maybe?)</p>
<p>There are several directives available. (TODO:
link to the other directives). The one we're<br />
interested in right now is <code>#[allow(unused)]</code></p>
<p>(TODO: Update based on the one with the <code>!</code>
as well and talk about the difference i.e.
<code>#![allow(unused)]</code></p>
<p>It's applied like this. Give it a shot
to see the error message.</p>
<h4 id="source"><a class="header" href="#source">SOURCE</a></h4>
<pre><code class="language-rust  noplayground  EXAMPLE1">#[allow(unused)]
fn main() {
  let alfa = 7;
  alfa = 9;
}</code></pre>
<h4 id="code-runner-96"><a class="header" href="#code-runner-96">CODE RUNNER</a></h4>
<pre><pre class="playground"><code class="language-rust  editable  CODE1"></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-error-message"><a class="header" href="#the-error-message">The Error Message</a></h1>
<p>Here's the error message</p>
<pre><code class="language-rust  noplayground">   Compiling playground v0.0.1 (/playground)
error[E0384]: cannot assign twice to immutable variable `alfa`
 --&gt; src/main.rs:4:3
  |
3 |   let alfa = 7;
  |       ----
  |       |
  |       first assignment to `alfa`
  |       help: consider making this binding mutable: `mut alfa`
4 |   alfa = 9;
  |   ^^^^^^^^ cannot assign twice to immutable variable

For more information about this error, try `rustc --explain E0384`.
error: could not compile `playground` due to previous error</code></pre>
<p>For now, the two lines we need to look at are:</p>
<pre><code class="language-rust noplayground">error[E0384]: cannot assign twice to immutable variable `alfa`</code></pre>
<p>and</p>
<pre><code class="language-rust noplayground">|       help: consider making this binding mutable: `mut alfa`</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-messages"><a class="header" href="#error-messages">Error Messages</a></h1>
<p>TODO: Make a collection of error message
showing some of the ways things can go
wrong.</p>
<p>Examples to use:</p>
<ul>
<li>Not sending a value to a function</li>
<li>Not putting a <code>;</code> after a line in a
function that needs it.</li>
</ul>
<p>See if there's a list of the most common
errors folks hit.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="variables---origian-with-types"><a class="header" href="#variables---origian-with-types">Variables - Origian with types</a></h1>
<p>This is the first version of the Variables page
that included type defintions. Moving to a version
that doesn't have that for now to see how it works</p>
<p>Keeping this here for reference.</p>
<hr />
<p>Variables in Rust are created using the following
structure:</p>
<ol>
<li>The <code>let</code> keyword</li>
<li>A name for the variable (e.g. <code>alfa</code>)</li>
<li>A <code>:</code> that acts as a separator</li>
<li>A data type</li>
<li>The <code>=</code> sign</li>
<li>The value to bind to it (e.g. <code>7</code>)</li>
<li>A <code>;</code> the ends the definition</li>
</ol>
<p>The data type from item 4 tells rust what
kind of content the variable can hold. For example,
it might be a number, or a letter, or full
sentence. We'll dig into data types in the
next chapter. We'll use <code>i32</code> (which
stands for a number) until we get there.</p>
<p>Putting it all together we get this:</p>
<pre><code class="language-rust  noplayground">let alfa: i32 = 7;</code></pre>
<p>Using that line in we can create
a full program that defines the <code>alfa</code>
variable then prints it out.</p>
<h4 id="source-code-99"><a class="header" href="#source-code-99">SOURCE CODE</a></h4>
<pre><code class="language-rust noplayground EXAMPLE1">fn main() {

  let alfa: i32 = 7;

  println!(&quot;The value is {}&quot;, alfa);

}</code></pre>
<h4 id="code-runner-97"><a class="header" href="#code-runner-97">CODE RUNNER</a></h4>
<pre><pre class="playground"><code class="language-rust editable CODE1"></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="if-let"><a class="header" href="#if-let">if let</a></h1>
<p>TODO: Do this after match</p>
<h4 id="source-code-100"><a class="header" href="#source-code-100">SOURCE CODE</a></h4>
<pre><code class="language-rust  noplayground  EXAMPLE1">fn main() {
}</code></pre>
<h3 id="code-runner-98"><a class="header" href="#code-runner-98">CODE RUNNER</a></h3>
<pre><pre class="playground"><code class="language-rust  editable  CODE1"></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="loops"><a class="header" href="#loops">Loops</a></h1>
<p>Moving this back in the stack since while and
for loops are much more common</p>
<h4 id="source-code-101"><a class="header" href="#source-code-101">SOURCE CODE</a></h4>
<pre><code class="language-rust  noplayground  EXAMPLE1">fn main() {

  let mut alfa = 1;

  loop {
    println!(&quot;alfa is {}&quot;, alfa);

    if alfa == 10 {
      break;
    }

    alfa += 1;
  }

}</code></pre>
<h3 id="code-runner-99"><a class="header" href="#code-runner-99">CODE RUNNER</a></h3>
<pre><pre class="playground"><code class="language-rust  editable  CODE1"></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="binding-values"><a class="header" href="#binding-values">Binding Values</a></h1>
<h4 id="source-code-102"><a class="header" href="#source-code-102">SOURCE CODE</a></h4>
<pre><code class="language-rust  noplayground  EXAMPLE1">fn main() {
  let mut alfa = 1;

  let bravo = loop {
    println!(&quot;alfa is {}&quot;, alfa);

    if alfa == 10 {
      break alfa;
    }

    alfa += 1;
  };

  println!(&quot;bravo is {}&quot;, bravo);

}</code></pre>
<h3 id="code-runner-100"><a class="header" href="#code-runner-100">CODE RUNNER</a></h3>
<pre><pre class="playground"><code class="language-rust  editable  CODE1"></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="labels"><a class="header" href="#labels">Labels</a></h1>
<p>You can add labels like this (not useful
yet, but we'll see where they become
helpful on the next page)</p>
<h4 id="source-code-103"><a class="header" href="#source-code-103">SOURCE CODE</a></h4>
<pre><code class="language-rust  noplayground  EXAMPLE1">fn main() {
  let mut alfa = 1;

  'outter_loop: loop {

    println!(&quot;alfa is {}&quot;, alfa);

    if alfa &gt;= 10 {
      break 'outter_loop;
    }

    alfa += 1;
  }
}</code></pre>
<h3 id="code-runner-101"><a class="header" href="#code-runner-101">CODE RUNNER</a></h3>
<pre><pre class="playground"><code class="language-rust  editable  CODE1"></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nested-loops"><a class="header" href="#nested-loops">Nested Loops</a></h1>
<p>Nested loops (one inside of another one) are
where labels become useful.</p>
<h4 id="source-code-104"><a class="header" href="#source-code-104">SOURCE CODE</a></h4>
<pre><code class="language-rust  noplayground  EXAMPLE1">fn main() {
  let mut alfa = 1;

  'outter_loop: loop {
    let mut bravo = 1;

    'inner_loop: loop {

      if bravo == 4 {
        break 'inner_loop;
      }

      if alfa == 5 {
        break 'outter_loop;
      }

      println!(&quot;alfa {} bravo {}&quot;, alfa, bravo);

      bravo += 1;

    }

    alfa += 1;
  }
}</code></pre>
<h3 id="code-runner-102"><a class="header" href="#code-runner-102">CODE RUNNER</a></h3>
<pre><pre class="playground"><code class="language-rust  editable  CODE1"></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fizz-buzz"><a class="header" href="#fizz-buzz">Fizz Buzz</a></h1>
<p>Not sure I'm goint to put Fizz 
Buzz in here or not, but one 
idea might be to do different
versions of it showing different
approaches. </p>
<h3 id="source-code-105"><a class="header" href="#source-code-105">SOURCE CODE</a></h3>
<pre><pre class="playground"><code class="language-rust  EXAMPLE1">fn main() {
  for count in 1..=20 {
    if count % 3 == 0 {
      if count % 5 == 0 {
        println!(&quot;FizzBuzz&quot;);
      } else {
        println!(&quot;Fizz&quot;);
      }
    } else if count % 5 == 0 {
      println!(&quot;Buzz&quot;);
    } else {
      println!(&quot;{}&quot;, count);
    }
  }
}</code></pre></pre>
<h3 id="code-runner-103"><a class="header" href="#code-runner-103">CODE RUNNER</a></h3>
<pre><pre class="playground"><code class="language-rust  editable  CODE1"></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-world---the-parts"><a class="header" href="#hello-world---the-parts">Hello, World - The Parts</a></h1>
<p>Let's take a look at the individual parts that make up our
&quot;Hello, World&quot; program.</p>
<pre><code class="language-rust  noplayground  EXAMPLE1">fn main() {
  println!(&quot;Hello, World&quot;);
}</code></pre>
<ul>
<li>
<p><code>fn</code> is short for function which is what we're
defining.</p>
</li>
<li>
<p><code>main</code> is the name we're assigning to the
function. In Rust, the <code>main</code> function is
used to kick things off.</p>
<p>Every rust program must have a <code>main</code>
function. It's the entry point that kicks things off.</p>
</li>
<li>
<p>The <code>()</code> at the end of <code>main()</code> is where
we define arguments that can be passed to the
function. They're empty here which means <code>main()</code>
doesn't accept any.</p>
</li>
<li>
<p>The opening <code>{</code> and <code>}</code> curly bracket set the starting
and ending points for the function's code block.</p>
</li>
<li>
<p><code>println!(&quot;Hello, World&quot;);</code> is what prints out the
text.</p>
</li>
</ul>
<p>We'll dig into more details about each of those elements
throughout the site.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a-complete-program"><a class="header" href="#a-complete-program">A Complete Program</a></h1>
<p>Let's look at the &quot;Hello, World&quot; code again:</p>
<pre><code class="language-rust  noplayground">fn main() {
  println!(&quot;Hello, World&quot;);
}</code></pre>
<p>Those three lines of code are a complete program.
It may be simple, but when you've typed them in
you've officially written Rust.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <div style="clear: both"></div>
                    </nav>

                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>


        <script>
            window.playground_line_numbers = true;
        </script>


        <script src="ace.js"></script>
        <script src="editor.js"></script>
        <script src="mode-rust.js"></script>
        <script src="theme-dawn.js"></script>
        <script src="theme-tomorrow_night.js"></script>


        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <!-- REMOVED TO ALLOW FOR MODULES -->
        <!--
        <script src="theme/typo-detector.js" type="module"></script>
        <script src="theme/step-by-step.js" type="module"></script>
        -->

        <script type="module">
          import { typoInit } from "./theme/typo-detector.js"
          typoInit();
        </script>

        <script type="module">
          import { stepByStepInit } from "./theme/step-by-step.js"
          stepByStepInit();
        </script>


        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
